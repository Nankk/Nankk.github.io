shadow$provide.module$node_modules$node_forge$lib$rsa=function(global,require,module,exports){function _encodePkcs1_v1_5(m,key,bt){var eb=forge.util.createBuffer();key=Math.ceil(key.n.bitLength()/8);if(m.length>key-11)throw eb=Error("Message is too long for PKCS#1 v1.5 padding."),eb.length=m.length,eb.max=key-11,eb;eb.putByte(0);eb.putByte(bt);key=key-3-m.length;if(0===bt||1===bt){bt=0===bt?0:255;for(var i=0;i<key;++i)eb.putByte(bt)}else for(;0<key;){var numZeros=0,padBytes=forge.random.getBytes(key);
for(i=0;i<key;++i)bt=padBytes.charCodeAt(i),0===bt?++numZeros:eb.putByte(bt);key=numZeros}eb.putByte(0);eb.putBytes(m);return eb}function _decodePkcs1_v1_5(em,key,pub,ml){key=Math.ceil(key.n.bitLength()/8);em=forge.util.createBuffer(em);var first=em.getByte(),bt=em.getByte();if(0!==first||pub&&0!==bt&&1!==bt||!pub&&2!=bt||pub&&0===bt&&"undefined"===typeof ml)throw Error("Encryption block is invalid.");pub=0;if(0===bt)for(pub=key-3-ml,ml=0;ml<pub;++ml){if(0!==em.getByte())throw Error("Encryption block is invalid.");
}else if(1===bt)for(pub=0;1<em.length();){if(255!==em.getByte()){--em.read;break}++pub}else if(2===bt)for(pub=0;1<em.length();){if(0===em.getByte()){--em.read;break}++pub}if(0!==em.getByte()||pub!==key-3-em.length())throw Error("Encryption block is invalid.");return em.getBytes()}function _generateKeyPair(state,options,callback$jscomp$0){function generate(){getPrime(state.pBits,function(err,num){if(err)return callback$jscomp$0(err);state.p=num;if(null!==state.q)return finish(err,state.q);getPrime(state.qBits,
finish)})}function getPrime(bits,callback){forge.prime.generateProbablePrime(bits,opts,callback)}function finish(err,num){if(err)return callback$jscomp$0(err);state.q=num;0>state.p.compareTo(state.q)&&(err=state.p,state.p=state.q,state.q=err);0!==state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE)?(state.p=null,generate()):0!==state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE)?(state.q=null,getPrime(state.qBits,finish)):(state.p1=state.p.subtract(BigInteger.ONE),
state.q1=state.q.subtract(BigInteger.ONE),state.phi=state.p1.multiply(state.q1),0!==state.phi.gcd(state.e).compareTo(BigInteger.ONE)?(state.p=state.q=null,generate()):(state.n=state.p.multiply(state.q),state.n.bitLength()!==state.bits?(state.q=null,getPrime(state.qBits,finish)):(err=state.e.modInverse(state.phi),state.keys={privateKey:pki.rsa.setPrivateKey(state.n,state.e,err,state.p,state.q,err.mod(state.p1),err.mod(state.q1),state.q.modInverse(state.p)),publicKey:pki.rsa.setPublicKey(state.n,state.e)},
callback$jscomp$0(null,state.keys))))}"function"===typeof options&&(callback$jscomp$0=options,options={});options=options||{};var opts={algorithm:{name:options.algorithm||"PRIMEINC",options:{workers:options.workers||2,workLoad:options.workLoad||100,workerScript:options.workerScript}}};"prng"in options&&(opts.prng=options.prng);generate()}function _bnToBytes(b){b=b.toString(16);"8"<=b[0]&&(b="00"+b);b=forge.util.hexToBytes(b);return 1<b.length&&(0===b.charCodeAt(0)&&0===(b.charCodeAt(1)&128)||255===
b.charCodeAt(0)&&128===(b.charCodeAt(1)&128))?b.substr(1):b}function _getMillerRabinTests(bits){return 100>=bits?27:150>=bits?18:200>=bits?15:250>=bits?12:300>=bits?9:350>=bits?8:400>=bits?7:500>=bits?6:600>=bits?5:800>=bits?4:1250>=bits?3:2}function _detectSubtleCrypto(fn){return"undefined"!==typeof util.globalScope&&"object"===typeof util.globalScope.crypto&&"object"===typeof util.globalScope.crypto.subtle&&"function"===typeof util.globalScope.crypto.subtle[fn]}function _detectSubtleMsCrypto(fn){return"undefined"!==
typeof util.globalScope&&"object"===typeof util.globalScope.msCrypto&&"object"===typeof util.globalScope.msCrypto.subtle&&"function"===typeof util.globalScope.msCrypto.subtle[fn]}function _intToUint8Array(x){x=forge.util.hexToBytes(x.toString(16));for(var buffer=new Uint8Array(x.length),i=0;i<x.length;++i)buffer[i]=x.charCodeAt(i);return buffer}var forge=require("module$node_modules$node_forge$lib$forge");require("module$node_modules$node_forge$lib$asn1");require("module$node_modules$node_forge$lib$jsbn");
require("module$node_modules$node_forge$lib$oids");require("module$node_modules$node_forge$lib$pkcs1");require("module$node_modules$node_forge$lib$prime");require("module$node_modules$node_forge$lib$random");require("module$node_modules$node_forge$lib$util");if("undefined"===typeof BigInteger)var BigInteger=forge.jsbn.BigInteger;var _crypto=forge.util.isNodejs?require("shadow$empty"):null,asn1=forge.asn1,util=forge.util;forge.pki=forge.pki||{};module.exports=forge.pki.rsa=forge.rsa=forge.rsa||{};
var pki=forge.pki,GCD_30_DELTA=[6,4,2,4,2,4,6,2],privateKeyValidator={name:"PrivateKeyInfo",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"PrivateKeyInfo.version",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,capture:"privateKeyVersion"},{name:"PrivateKeyInfo.privateKeyAlgorithm",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,
constructed:!1,capture:"privateKeyOid"}]},{name:"PrivateKeyInfo",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:!1,capture:"privateKey"}]},rsaPrivateKeyValidator={name:"RSAPrivateKey",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"RSAPrivateKey.version",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,capture:"privateKeyVersion"},{name:"RSAPrivateKey.modulus",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,
capture:"privateKeyModulus"},{name:"RSAPrivateKey.publicExponent",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,capture:"privateKeyPublicExponent"},{name:"RSAPrivateKey.privateExponent",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,capture:"privateKeyPrivateExponent"},{name:"RSAPrivateKey.prime1",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,capture:"privateKeyPrime1"},{name:"RSAPrivateKey.prime2",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,
constructed:!1,capture:"privateKeyPrime2"},{name:"RSAPrivateKey.exponent1",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,capture:"privateKeyExponent1"},{name:"RSAPrivateKey.exponent2",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,capture:"privateKeyExponent2"},{name:"RSAPrivateKey.coefficient",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,capture:"privateKeyCoefficient"}]},rsaPublicKeyValidator={name:"RSAPublicKey",tagClass:asn1.Class.UNIVERSAL,
type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"RSAPublicKey.modulus",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,capture:"publicKeyModulus"},{name:"RSAPublicKey.exponent",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,capture:"publicKeyExponent"}]},publicKeyValidator=forge.pki.rsa.publicKeyValidator={name:"SubjectPublicKeyInfo",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,captureAsn1:"subjectPublicKeyInfo",value:[{name:"SubjectPublicKeyInfo.AlgorithmIdentifier",
tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"publicKeyOid"}]},{name:"SubjectPublicKeyInfo.subjectPublicKey",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:!1,value:[{name:"SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,optional:!0,captureAsn1:"rsaPublicKey"}]}]},emsaPkcs1v15encode=
function(md){if(md.algorithm in pki.oids)var oid=pki.oids[md.algorithm];else throw oid=Error("Unknown message digest algorithm."),oid.algorithm=md.algorithm,oid;var oidBytes=asn1.oidToDer(oid).getBytes();oid=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[]);var digestAlgorithm=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[]);digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,oidBytes));digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,
!1,""));md=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,md.digest().getBytes());oid.value.push(digestAlgorithm);oid.value.push(md);return asn1.toDer(oid).getBytes()},_modPow=function(x,key,pub){if(pub)return x.modPow(key.e,key.n);if(!key.p||!key.q)return x.modPow(key.d,key.n);key.dP||(key.dP=key.d.mod(key.p.subtract(BigInteger.ONE)));key.dQ||(key.dQ=key.d.mod(key.q.subtract(BigInteger.ONE)));key.qInv||(key.qInv=key.q.modInverse(key.p));do pub=new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength()/
8)),16);while(0<=pub.compareTo(key.n)||!pub.gcd(key.n).equals(BigInteger.ONE));x=x.multiply(pub.modPow(key.e,key.n)).mod(key.n);var xp=x.mod(key.p).modPow(key.dP,key.p);for(x=x.mod(key.q).modPow(key.dQ,key.q);0>xp.compareTo(x);)xp=xp.add(key.p);x=xp.subtract(x).multiply(key.qInv).mod(key.p).multiply(key.q).add(x);return x=x.multiply(pub.modInverse(key.n)).mod(key.n)};pki.rsa.encrypt=function(m,key,bt){var pub=bt,k=Math.ceil(key.n.bitLength()/8);!1!==bt&&!0!==bt?(pub=2===bt,bt=_encodePkcs1_v1_5(m,
key,bt)):(bt=forge.util.createBuffer(),bt.putBytes(m));m=new BigInteger(bt.toHex(),16);key=_modPow(m,key,pub).toString(16);pub=forge.util.createBuffer();for(k-=Math.ceil(key.length/2);0<k;)pub.putByte(0),--k;pub.putBytes(forge.util.hexToBytes(key));return pub.getBytes()};pki.rsa.decrypt=function(ed,key,pub,ml){var k=Math.ceil(key.n.bitLength()/8);if(ed.length!==k)throw key=Error("Encrypted message length is invalid."),key.length=ed.length,key.expected=k,key;ed=new BigInteger(forge.util.createBuffer(ed).toHex(),
16);if(0<=ed.compareTo(key.n))throw Error("Encrypted message is invalid.");ed=_modPow(ed,key,pub).toString(16);var eb=forge.util.createBuffer();for(k-=Math.ceil(ed.length/2);0<k;)eb.putByte(0),--k;eb.putBytes(forge.util.hexToBytes(ed));return!1!==ml?_decodePkcs1_v1_5(eb.getBytes(),key,pub):eb.getBytes()};pki.rsa.createKeyPairGenerationState=function(bits,e,options){"string"===typeof bits&&(bits=parseInt(bits,10));bits=bits||2048;options=options||{};var prng=options.prng||forge.random,rng={nextBytes:function(x){for(var b=
prng.getBytesSync(x.length),i=0;i<x.length;++i)x[i]=b.charCodeAt(i)}};options=options.algorithm||"PRIMEINC";if("PRIMEINC"===options)bits={algorithm:options,state:0,bits:bits,rng:rng,eInt:e||65537,e:new BigInteger(null),p:null,q:null,qBits:bits>>1,pBits:bits-(bits>>1),pqState:0,num:null,keys:null},bits.e.fromInt(bits.eInt);else throw Error("Invalid key generation algorithm: "+options);return bits};pki.rsa.stepKeyPairGenerationState=function(state,n){"algorithm"in state||(state.algorithm="PRIMEINC");
var THIRTY=new BigInteger(null);THIRTY.fromInt(30);for(var deltaIdx=0,op_or=function(x,y){return x|y},t1=+new Date,t2,total=0;null===state.keys&&(0>=n||total<n);){if(0===state.state){t2=null===state.p?state.pBits:state.qBits;var bits1=t2-1;0===state.pqState?(state.num=new BigInteger(t2,state.rng),state.num.testBit(bits1)||state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1),op_or,state.num),state.num.dAddOffset(31-state.num.mod(THIRTY).byteValue(),0),deltaIdx=0,++state.pqState):1===state.pqState?state.num.bitLength()>
t2?state.pqState=0:state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))?++state.pqState:state.num.dAddOffset(GCD_30_DELTA[deltaIdx++%8],0):2===state.pqState?state.pqState=0===state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE)?3:0:3===state.pqState&&(state.pqState=0,null===state.p?state.p=state.num:state.q=state.num,null!==state.p&&null!==state.q&&++state.state,state.num=null)}else 1===state.state?(0>state.p.compareTo(state.q)&&(state.num=state.p,state.p=state.q,
state.q=state.num),++state.state):2===state.state?(state.p1=state.p.subtract(BigInteger.ONE),state.q1=state.q.subtract(BigInteger.ONE),state.phi=state.p1.multiply(state.q1),++state.state):3===state.state?0===state.phi.gcd(state.e).compareTo(BigInteger.ONE)?++state.state:(state.p=null,state.q=null,state.state=0):4===state.state?(state.n=state.p.multiply(state.q),state.n.bitLength()===state.bits?++state.state:(state.q=null,state.state=0)):5===state.state&&(t2=state.e.modInverse(state.phi),state.keys=
{privateKey:pki.rsa.setPrivateKey(state.n,state.e,t2,state.p,state.q,t2.mod(state.p1),t2.mod(state.q1),state.q.modInverse(state.p)),publicKey:pki.rsa.setPublicKey(state.n,state.e)});t2=+new Date;total+=t2-t1;t1=t2}return null!==state.keys};pki.rsa.generateKeyPair=function(bits,e$jscomp$1,options,callback){1===arguments.length?"object"===typeof bits?(options=bits,bits=void 0):"function"===typeof bits&&(callback=bits,bits=void 0):2===arguments.length?"number"===typeof bits?"function"===typeof e$jscomp$1?
(callback=e$jscomp$1,e$jscomp$1=void 0):"number"!==typeof e$jscomp$1&&(options=e$jscomp$1,e$jscomp$1=void 0):(options=bits,callback=e$jscomp$1,e$jscomp$1=bits=void 0):3===arguments.length&&("number"===typeof e$jscomp$1?"function"===typeof options&&(callback=options,options=void 0):(callback=options,options=e$jscomp$1,e$jscomp$1=void 0));options=options||{};void 0===bits&&(bits=options.bits||2048);void 0===e$jscomp$1&&(e$jscomp$1=options.e||65537);if(!forge.options.usePureJavaScript&&!options.prng&&
256<=bits&&16384>=bits&&(65537===e$jscomp$1||3===e$jscomp$1))if(callback){if(forge.util.isNodejs&&"function"===typeof _crypto.generateKeyPair)return _crypto.generateKeyPair("rsa",{modulusLength:bits,publicExponent:e$jscomp$1,publicKeyEncoding:{type:"spki",format:"pem"},privateKeyEncoding:{type:"pkcs8",format:"pem"}},function(err,pub,priv){if(err)return callback(err);callback(null,{privateKey:pki.privateKeyFromPem(priv),publicKey:pki.publicKeyFromPem(pub)})});if(_detectSubtleCrypto("generateKey")&&
_detectSubtleCrypto("exportKey"))return util.globalScope.crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:bits,publicExponent:_intToUint8Array(e$jscomp$1),hash:{name:"SHA-256"}},!0,["sign","verify"]).then(function(pair){return util.globalScope.crypto.subtle.exportKey("pkcs8",pair.privateKey)}).then(void 0,function(err){callback(err)}).then(function(pkcs8){pkcs8&&(pkcs8=pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8))),callback(null,{privateKey:pkcs8,publicKey:pki.setRsaPublicKey(pkcs8.n,
pkcs8.e)}))});if(_detectSubtleMsCrypto("generateKey")&&_detectSubtleMsCrypto("exportKey")){var genOp=util.globalScope.msCrypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:bits,publicExponent:_intToUint8Array(e$jscomp$1),hash:{name:"SHA-256"}},!0,["sign","verify"]);genOp.oncomplete=function(e$jscomp$0){e$jscomp$0=util.globalScope.msCrypto.subtle.exportKey("pkcs8",e$jscomp$0.target.result.privateKey);e$jscomp$0.oncomplete=function(e){e=pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(e.target.result)));
callback(null,{privateKey:e,publicKey:pki.setRsaPublicKey(e.n,e.e)})};e$jscomp$0.onerror=function(err){callback(err)}};genOp.onerror=function(err){callback(err)};return}}else if(forge.util.isNodejs&&"function"===typeof _crypto.generateKeyPairSync)return genOp=_crypto.generateKeyPairSync("rsa",{modulusLength:bits,publicExponent:e$jscomp$1,publicKeyEncoding:{type:"spki",format:"pem"},privateKeyEncoding:{type:"pkcs8",format:"pem"}}),{privateKey:pki.privateKeyFromPem(genOp.privateKey),publicKey:pki.publicKeyFromPem(genOp.publicKey)};
genOp=pki.rsa.createKeyPairGenerationState(bits,e$jscomp$1,options);if(!callback)return pki.rsa.stepKeyPairGenerationState(genOp,0),genOp.keys;_generateKeyPair(genOp,options,callback)};pki.setRsaPublicKey=pki.rsa.setPublicKey=function(n,e$jscomp$0){var key$jscomp$0={n:n,e:e$jscomp$0,encrypt:function(data,scheme,schemeOptions){"string"===typeof scheme?scheme=scheme.toUpperCase():void 0===scheme&&(scheme="RSAES-PKCS1-V1_5");if("RSAES-PKCS1-V1_5"===scheme)scheme={encode:function(m,key,pub){return _encodePkcs1_v1_5(m,
key,2).getBytes()}};else if("RSA-OAEP"===scheme||"RSAES-OAEP"===scheme)scheme={encode:function(m,key){return forge.pkcs1.encode_rsa_oaep(key,m,schemeOptions)}};else if(-1!==["RAW","NONE","NULL",null].indexOf(scheme))scheme={encode:function(e){return e}};else if("string"===typeof scheme)throw Error('Unsupported encryption scheme: "'+scheme+'".');data=scheme.encode(data,key$jscomp$0,!0);return pki.rsa.encrypt(data,key$jscomp$0,!0)},verify:function(digest$jscomp$0,signature,scheme){"string"===typeof scheme?
scheme=scheme.toUpperCase():void 0===scheme&&(scheme="RSASSA-PKCS1-V1_5");if("RSASSA-PKCS1-V1_5"===scheme)scheme={verify:function(digest,d){d=_decodePkcs1_v1_5(d,key$jscomp$0,!0);d=asn1.fromDer(d);return digest===d.value[1].value}};else if("NONE"===scheme||"NULL"===scheme||null===scheme)scheme={verify:function(digest,d){d=_decodePkcs1_v1_5(d,key$jscomp$0,!0);return digest===d}};signature=pki.rsa.decrypt(signature,key$jscomp$0,!0,!1);return scheme.verify(digest$jscomp$0,signature,key$jscomp$0.n.bitLength())}};
return key$jscomp$0};pki.setRsaPrivateKey=pki.rsa.setPrivateKey=function(n,e,d$jscomp$0,p,q,dP,dQ,qInv){var key$jscomp$0={n:n,e:e,d:d$jscomp$0,p:p,q:q,dP:dP,dQ:dQ,qInv:qInv,decrypt:function(data,scheme,schemeOptions){"string"===typeof scheme?scheme=scheme.toUpperCase():void 0===scheme&&(scheme="RSAES-PKCS1-V1_5");data=pki.rsa.decrypt(data,key$jscomp$0,!1,!1);if("RSAES-PKCS1-V1_5"===scheme)scheme={decode:_decodePkcs1_v1_5};else if("RSA-OAEP"===scheme||"RSAES-OAEP"===scheme)scheme={decode:function(d,
key){return forge.pkcs1.decode_rsa_oaep(key,d,schemeOptions)}};else if(-1!==["RAW","NONE","NULL",null].indexOf(scheme))scheme={decode:function(d){return d}};else throw Error('Unsupported encryption scheme: "'+scheme+'".');return scheme.decode(data,key$jscomp$0,!1)},sign:function(md,scheme){var bt=!1;"string"===typeof scheme&&(scheme=scheme.toUpperCase());if(void 0===scheme||"RSASSA-PKCS1-V1_5"===scheme)scheme={encode:emsaPkcs1v15encode},bt=1;else if("NONE"===scheme||"NULL"===scheme||null===scheme)scheme=
{encode:function(){return md}},bt=1;scheme=scheme.encode(md,key$jscomp$0.n.bitLength());return pki.rsa.encrypt(scheme,key$jscomp$0,bt)}};return key$jscomp$0};pki.wrapRsaPrivateKey=function(rsaKey){return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,asn1.integerToDer(0).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,!1,"")]),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,asn1.toDer(rsaKey).getBytes())])};pki.privateKeyFromAsn1=function(obj){var capture={},errors=[];asn1.validate(obj,privateKeyValidator,capture,errors)&&(obj=asn1.fromDer(forge.util.createBuffer(capture.privateKey)));capture={};errors=[];if(!asn1.validate(obj,rsaPrivateKeyValidator,capture,errors))throw capture=Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey."),
capture.errors=errors,capture;errors=forge.util.createBuffer(capture.privateKeyModulus).toHex();obj=forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();var d=forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();var p=forge.util.createBuffer(capture.privateKeyPrime1).toHex();var q=forge.util.createBuffer(capture.privateKeyPrime2).toHex();var dP=forge.util.createBuffer(capture.privateKeyExponent1).toHex();var dQ=forge.util.createBuffer(capture.privateKeyExponent2).toHex();
capture=forge.util.createBuffer(capture.privateKeyCoefficient).toHex();return pki.setRsaPrivateKey(new BigInteger(errors,16),new BigInteger(obj,16),new BigInteger(d,16),new BigInteger(p,16),new BigInteger(q,16),new BigInteger(dP,16),new BigInteger(dQ,16),new BigInteger(capture,16))};pki.privateKeyToAsn1=pki.privateKeyToRSAPrivateKey=function(key){return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,asn1.integerToDer(0).getBytes()),asn1.create(asn1.Class.UNIVERSAL,
asn1.Type.INTEGER,!1,_bnToBytes(key.n)),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,_bnToBytes(key.e)),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,_bnToBytes(key.d)),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,_bnToBytes(key.p)),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,_bnToBytes(key.q)),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,_bnToBytes(key.dP)),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,_bnToBytes(key.dQ)),asn1.create(asn1.Class.UNIVERSAL,
asn1.Type.INTEGER,!1,_bnToBytes(key.qInv))])};pki.publicKeyFromAsn1=function(obj){var capture={},errors=[];if(asn1.validate(obj,publicKeyValidator,capture,errors)){errors=asn1.derToOid(capture.publicKeyOid);if(errors!==pki.oids.rsaEncryption)throw capture=Error("Cannot read public key. Unknown OID."),capture.oid=errors,capture;obj=capture.rsaPublicKey}errors=[];if(!asn1.validate(obj,rsaPublicKeyValidator,capture,errors))throw capture=Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey."),
capture.errors=errors,capture;errors=forge.util.createBuffer(capture.publicKeyModulus).toHex();capture=forge.util.createBuffer(capture.publicKeyExponent).toHex();return pki.setRsaPublicKey(new BigInteger(errors,16),new BigInteger(capture,16))};pki.publicKeyToAsn1=pki.publicKeyToSubjectPublicKeyInfo=function(key){return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,!1,"")]),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,!1,[pki.publicKeyToRSAPublicKey(key)])])};pki.publicKeyToRSAPublicKey=function(key){return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,_bnToBytes(key.n)),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,_bnToBytes(key.e))])}}
//# sourceMappingURL=module$node_modules$node_forge$lib$rsa.js.map
