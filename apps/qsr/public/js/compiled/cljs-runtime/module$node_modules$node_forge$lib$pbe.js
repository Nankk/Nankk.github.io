shadow$provide.module$node_modules$node_forge$lib$pbe=function(global,require,module,exports){function hash(md,bytes){return md.start().update(bytes).digest().getBytes()}function prfOidToMessageDigest(prfOid){if(prfOid){var prfAlgorithm=pki.oids[asn1.derToOid(prfOid)];if(!prfAlgorithm)throw prfAlgorithm=Error("Unsupported PRF OID."),prfAlgorithm.oid=prfOid,prfAlgorithm.supported=["hmacWithSHA1","hmacWithSHA224","hmacWithSHA256","hmacWithSHA384","hmacWithSHA512"],prfAlgorithm;}else prfAlgorithm="hmacWithSHA1";
return prfAlgorithmToMessageDigest(prfAlgorithm)}function prfAlgorithmToMessageDigest(prfAlgorithm){var factory=forge.md;switch(prfAlgorithm){case "hmacWithSHA224":factory=forge.md.sha512;case "hmacWithSHA1":case "hmacWithSHA256":case "hmacWithSHA384":case "hmacWithSHA512":prfAlgorithm=prfAlgorithm.substr(8).toLowerCase();break;default:throw factory=Error("Unsupported PRF algorithm."),factory.algorithm=prfAlgorithm,factory.supported=["hmacWithSHA1","hmacWithSHA224","hmacWithSHA256","hmacWithSHA384",
"hmacWithSHA512"],factory;}if(!(factory&&prfAlgorithm in factory))throw Error("Unknown hash algorithm: "+prfAlgorithm);return factory[prfAlgorithm].create()}var forge=require("module$node_modules$node_forge$lib$forge");require("module$node_modules$node_forge$lib$aes");require("module$node_modules$node_forge$lib$asn1");require("module$node_modules$node_forge$lib$des");require("module$node_modules$node_forge$lib$md");require("module$node_modules$node_forge$lib$oids");require("module$node_modules$node_forge$lib$pbkdf2");
require("module$node_modules$node_forge$lib$pem");require("module$node_modules$node_forge$lib$random");require("module$node_modules$node_forge$lib$rc2");require("module$node_modules$node_forge$lib$rsa");require("module$node_modules$node_forge$lib$util");if("undefined"===typeof BigInteger)var BigInteger=forge.jsbn.BigInteger;var asn1=forge.asn1,pki=forge.pki=forge.pki||{};module.exports=pki.pbe=forge.pbe=forge.pbe||{};var oids=pki.oids,encryptedPrivateKeyValidator={name:"EncryptedPrivateKeyInfo",tagClass:asn1.Class.UNIVERSAL,
type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedPrivateKeyInfo.encryptionAlgorithm",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"encryptionOid"},{name:"AlgorithmIdentifier.parameters",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,captureAsn1:"encryptionParams"}]},{name:"EncryptedPrivateKeyInfo.encryptedData",tagClass:asn1.Class.UNIVERSAL,
type:asn1.Type.OCTETSTRING,constructed:!1,capture:"encryptedData"}]},PBES2AlgorithmsValidator={name:"PBES2Algorithms",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.keyDerivationFunc",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.keyDerivationFunc.oid",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"kdfOid"},{name:"PBES2Algorithms.params",tagClass:asn1.Class.UNIVERSAL,
type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.params.salt",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:!1,capture:"kdfSalt"},{name:"PBES2Algorithms.params.iterationCount",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,capture:"kdfIterationCount"},{name:"PBES2Algorithms.params.keyLength",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,optional:!0,capture:"keyLength"},{name:"PBES2Algorithms.params.prf",tagClass:asn1.Class.UNIVERSAL,
type:asn1.Type.SEQUENCE,constructed:!0,optional:!0,value:[{name:"PBES2Algorithms.params.prf.algorithm",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"prfOid"}]}]}]},{name:"PBES2Algorithms.encryptionScheme",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.encryptionScheme.oid",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"encOid"},{name:"PBES2Algorithms.encryptionScheme.iv",tagClass:asn1.Class.UNIVERSAL,
type:asn1.Type.OCTETSTRING,constructed:!1,capture:"encIv"}]}]},pkcs12PbeParamsValidator={name:"pkcs-12PbeParams",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"pkcs-12PbeParams.salt",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:!1,capture:"salt"},{name:"pkcs-12PbeParams.iterations",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,capture:"iterations"}]};pki.encryptPrivateKeyInfo=function(obj,password,options){options=options||
{};options.saltSize=options.saltSize||8;options.count=options.count||2048;options.algorithm=options.algorithm||"aes128";options.prfAlgorithm=options.prfAlgorithm||"sha1";var salt=forge.random.getBytesSync(options.saltSize),count=options.count,countBytes=asn1.integerToDer(count),dkLen;if(0===options.algorithm.indexOf("aes")||"des"===options.algorithm){switch(options.algorithm){case "aes128":var ivLen=dkLen=16;var encOid=oids["aes128-CBC"];var cipherFn=forge.aes.createEncryptionCipher;break;case "aes192":dkLen=
24;ivLen=16;encOid=oids["aes192-CBC"];cipherFn=forge.aes.createEncryptionCipher;break;case "aes256":dkLen=32;ivLen=16;encOid=oids["aes256-CBC"];cipherFn=forge.aes.createEncryptionCipher;break;case "des":ivLen=dkLen=8;encOid=oids.desCBC;cipherFn=forge.des.createEncryptionCipher;break;default:throw salt=Error("Cannot encrypt private key. Unknown encryption algorithm."),salt.algorithm=options.algorithm,salt;}options="hmacWith"+options.prfAlgorithm.toUpperCase();var md=prfAlgorithmToMessageDigest(options);
md=forge.pkcs5.pbkdf2(password,salt,count,dkLen,md);password=forge.random.getBytesSync(ivLen);count=cipherFn(md);count.start(password);count.update(asn1.toDer(obj));count.finish();obj=count.output.getBytes();salt=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,salt),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,countBytes.getBytes())]);"hmacWithSHA1"!==options&&salt.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,
!1,forge.util.hexToBytes(dkLen.toString(16))),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(pki.oids[options]).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,!1,"")]));salt=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(oids.pkcs5PBES2).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,
!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(oids.pkcs5PBKDF2).getBytes()),salt]),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(encOid).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,password)])])])}else if("3des"===options.algorithm)dkLen=24,encOid=new forge.util.ByteBuffer(salt),md=pki.pbe.generatePkcs12Key(password,encOid,1,count,dkLen),password=pki.pbe.generatePkcs12Key(password,
encOid,2,count,dkLen),count=forge.des.createEncryptionCipher(md),count.start(password),count.update(asn1.toDer(obj)),count.finish(),obj=count.output.getBytes(),salt=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,salt),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,
!1,countBytes.getBytes())])]);else throw salt=Error("Cannot encrypt private key. Unknown encryption algorithm."),salt.algorithm=options.algorithm,salt;return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[salt,asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,obj)])};pki.decryptPrivateKeyInfo=function(obj,password){var rval=null,capture={},errors=[];if(!asn1.validate(obj,encryptedPrivateKeyValidator,capture,errors))throw rval=Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo."),
rval.errors=errors,rval;errors=asn1.derToOid(capture.encryptionOid);password=pki.pbe.getCipher(errors,capture.encryptionParams,password);capture=forge.util.createBuffer(capture.encryptedData);password.update(capture);password.finish()&&(rval=asn1.fromDer(password.output));return rval};pki.encryptedPrivateKeyToPem=function(epki,maxline){epki={type:"ENCRYPTED PRIVATE KEY",body:asn1.toDer(epki).getBytes()};return forge.pem.encode(epki,{maxline:maxline})};pki.encryptedPrivateKeyFromPem=function(pem){pem=
forge.pem.decode(pem)[0];if("ENCRYPTED PRIVATE KEY"!==pem.type){var error=Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');error.headerType=pem.type;throw error;}if(pem.procType&&"ENCRYPTED"===pem.procType.type)throw Error("Could not convert encrypted private key from PEM; PEM is encrypted.");return asn1.fromDer(pem.body)};pki.encryptRsaPrivateKey=function(rsaKey,password,options){options=options||{};if(!options.legacy)return rsaKey=pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey)),
rsaKey=pki.encryptPrivateKeyInfo(rsaKey,password,options),pki.encryptedPrivateKeyToPem(rsaKey);switch(options.algorithm){case "aes128":options="AES-128-CBC";var dkLen=16;var iv=forge.random.getBytesSync(16);var cipherFn=forge.aes.createEncryptionCipher;break;case "aes192":options="AES-192-CBC";dkLen=24;iv=forge.random.getBytesSync(16);cipherFn=forge.aes.createEncryptionCipher;break;case "aes256":options="AES-256-CBC";dkLen=32;iv=forge.random.getBytesSync(16);cipherFn=forge.aes.createEncryptionCipher;
break;case "3des":options="DES-EDE3-CBC";dkLen=24;iv=forge.random.getBytesSync(8);cipherFn=forge.des.createEncryptionCipher;break;case "des":options="DES-CBC";dkLen=8;iv=forge.random.getBytesSync(8);cipherFn=forge.des.createEncryptionCipher;break;default:throw rsaKey=Error('Could not encrypt RSA private key; unsupported encryption algorithm "'+options.algorithm+'".'),rsaKey.algorithm=options.algorithm,rsaKey;}password=forge.pbe.opensslDeriveBytes(password,iv.substr(0,8),dkLen);password=cipherFn(password);
password.start(iv);password.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));password.finish();rsaKey={type:"RSA PRIVATE KEY",procType:{version:"4",type:"ENCRYPTED"},dekInfo:{algorithm:options,parameters:forge.util.bytesToHex(iv).toUpperCase()},body:password.output.getBytes()};return forge.pem.encode(rsaKey)};pki.decryptRsaPrivateKey=function(pem,password){var rval=null;pem=forge.pem.decode(pem)[0];if("ENCRYPTED PRIVATE KEY"!==pem.type&&"PRIVATE KEY"!==pem.type&&"RSA PRIVATE KEY"!==pem.type)throw password=
Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".'),password.headerType=password,password;if(pem.procType&&"ENCRYPTED"===pem.procType.type){switch(pem.dekInfo.algorithm){case "DES-CBC":var dkLen=8;var cipherFn=forge.des.createDecryptionCipher;break;case "DES-EDE3-CBC":dkLen=24;cipherFn=forge.des.createDecryptionCipher;break;case "AES-128-CBC":dkLen=16;cipherFn=forge.aes.createDecryptionCipher;break;case "AES-192-CBC":dkLen=
24;cipherFn=forge.aes.createDecryptionCipher;break;case "AES-256-CBC":dkLen=32;cipherFn=forge.aes.createDecryptionCipher;break;case "RC2-40-CBC":dkLen=5;cipherFn=function(key){return forge.rc2.createDecryptionCipher(key,40)};break;case "RC2-64-CBC":dkLen=8;cipherFn=function(key){return forge.rc2.createDecryptionCipher(key,64)};break;case "RC2-128-CBC":dkLen=16;cipherFn=function(key){return forge.rc2.createDecryptionCipher(key,128)};break;default:throw password=Error('Could not decrypt private key; unsupported encryption algorithm "'+
pem.dekInfo.algorithm+'".'),password.algorithm=pem.dekInfo.algorithm,password;}var iv=forge.util.hexToBytes(pem.dekInfo.parameters);dkLen=forge.pbe.opensslDeriveBytes(password,iv.substr(0,8),dkLen);cipherFn=cipherFn(dkLen);cipherFn.start(iv);cipherFn.update(forge.util.createBuffer(pem.body));if(cipherFn.finish())rval=cipherFn.output.getBytes();else return rval}else rval=pem.body;rval="ENCRYPTED PRIVATE KEY"===pem.type?pki.decryptPrivateKeyInfo(asn1.fromDer(rval),password):asn1.fromDer(rval);null!==
rval&&(rval=pki.privateKeyFromAsn1(rval));return rval};pki.pbe.generatePkcs12Key=function(password,salt,id,iter,n,md){var j,l;if("undefined"===typeof md||null===md){if(!("sha1"in forge.md))throw Error('"sha1" hash algorithm unavailable.');md=forge.md.sha1.create()}var u=md.digestLength,v=md.blockLength,result=new forge.util.ByteBuffer,passBuf=new forge.util.ByteBuffer;if(null!==password&&void 0!==password){for(l=0;l<password.length;l++)passBuf.putInt16(password.charCodeAt(l));passBuf.putInt16(0)}password=
passBuf.length();var s=salt.length(),D=new forge.util.ByteBuffer;D.fillWithByte(id,v);var Slen=v*Math.ceil(s/v);id=new forge.util.ByteBuffer;for(l=0;l<Slen;l++)id.putByte(salt.at(l%s));Slen=v*Math.ceil(password/v);salt=new forge.util.ByteBuffer;for(l=0;l<Slen;l++)salt.putByte(passBuf.at(l%password));passBuf=id;passBuf.putBuffer(salt);salt=Math.ceil(n/u);for(id=1;id<=salt;id++){Slen=new forge.util.ByteBuffer;Slen.putBytes(D.bytes());Slen.putBytes(passBuf.bytes());for(l=0;l<iter;l++)md.start(),md.update(Slen.getBytes()),
Slen=md.digest();var B=new forge.util.ByteBuffer;for(l=0;l<v;l++)B.putByte(Slen.at(l%u));var k=Math.ceil(s/v)+Math.ceil(password/v),Inew=new forge.util.ByteBuffer;for(j=0;j<k;j++){var chunk=new forge.util.ByteBuffer(passBuf.getBytes(v)),x=511;for(l=B.length()-1;0<=l;l--)x>>=8,x+=B.at(l)+chunk.at(l),chunk.setAt(l,x&255);Inew.putBuffer(chunk)}passBuf=Inew;result.putBuffer(Slen)}result.truncate(result.length()-n);return result};pki.pbe.getCipher=function(oid,params,password){switch(oid){case pki.oids.pkcs5PBES2:return pki.pbe.getCipherForPBES2(oid,
params,password);case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:return pki.pbe.getCipherForPKCS12PBE(oid,params,password);default:throw params=Error("Cannot read encrypted PBE data block. Unsupported OID."),params.oid=oid,params.supportedOids=["pkcs5PBES2","pbeWithSHAAnd3-KeyTripleDES-CBC","pbewithSHAAnd40BitRC2-CBC"],params;}};pki.pbe.getCipherForPBES2=function(oid,params,password){var capture={};oid=[];if(!asn1.validate(params,PBES2AlgorithmsValidator,
capture,oid)){var error=Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");error.errors=oid;throw error;}oid=asn1.derToOid(capture.kdfOid);if(oid!==pki.oids.pkcs5PBKDF2)throw error=Error("Cannot read encrypted private key. Unsupported key derivation function OID."),error.oid=oid,error.supportedOids=["pkcs5PBKDF2"],error;oid=asn1.derToOid(capture.encOid);if(oid!==pki.oids["aes128-CBC"]&&oid!==pki.oids["aes192-CBC"]&&oid!==pki.oids["aes256-CBC"]&&
oid!==pki.oids["des-EDE3-CBC"]&&oid!==pki.oids.desCBC)throw error=Error("Cannot read encrypted private key. Unsupported encryption scheme OID."),error.oid=oid,error.supportedOids=["aes128-CBC","aes192-CBC","aes256-CBC","des-EDE3-CBC","desCBC"],error;params=capture.kdfSalt;var count=forge.util.createBuffer(capture.kdfIterationCount);count=count.getInt(count.length()<<3);switch(pki.oids[oid]){case "aes128-CBC":var dkLen=16;error=forge.aes.createDecryptionCipher;break;case "aes192-CBC":dkLen=24;error=
forge.aes.createDecryptionCipher;break;case "aes256-CBC":dkLen=32;error=forge.aes.createDecryptionCipher;break;case "des-EDE3-CBC":dkLen=24;error=forge.des.createDecryptionCipher;break;case "desCBC":dkLen=8,error=forge.des.createDecryptionCipher}oid=prfOidToMessageDigest(capture.prfOid);password=forge.pkcs5.pbkdf2(password,params,count,dkLen,oid);capture=capture.encIv;error=error(password);error.start(capture);return error};pki.pbe.getCipherForPKCS12PBE=function(oid,params,password){var capture={},
errors=[];if(!asn1.validate(params,pkcs12PbeParamsValidator,capture,errors))throw password=Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo."),password.errors=errors,password;errors=forge.util.createBuffer(capture.salt);params=forge.util.createBuffer(capture.iterations);params=params.getInt(params.length()<<3);switch(oid){case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:var dkLen=24;var dIvLen=8;oid=forge.des.startDecrypting;
break;case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:dkLen=5;dIvLen=8;oid=function(key,iv){key=forge.rc2.createDecryptionCipher(key,40);key.start(iv,null);return key};break;default:throw password=Error("Cannot read PKCS #12 PBE data block. Unsupported OID."),password.oid=oid,password;}capture=prfOidToMessageDigest(capture.prfOid);dkLen=pki.pbe.generatePkcs12Key(password,errors,1,params,dkLen,capture);capture.start();password=pki.pbe.generatePkcs12Key(password,errors,2,params,dIvLen,capture);return oid(dkLen,
password)};pki.pbe.opensslDeriveBytes=function(password,salt,dkLen,md){if("undefined"===typeof md||null===md){if(!("md5"in forge.md))throw Error('"md5" hash algorithm unavailable.');md=forge.md.md5.create()}null===salt&&(salt="");for(var digests=[hash(md,password+salt)],length=16,i=1;length<dkLen;++i,length+=16)digests.push(hash(md,digests[i-1]+password+salt));return digests.join("").substr(0,dkLen)}}
//# sourceMappingURL=module$node_modules$node_forge$lib$pbe.js.map
