shadow$provide.module$node_modules$node_forge$lib$aes=function(global,require,module,exports){function registerAlgorithm(name,mode){forge.cipher.registerAlgorithm(name,function(){return new forge.aes.Algorithm(name,mode)})}function initialize(){init=!0;rcon=[0,1,2,4,8,16,32,64,128,27,54];for(var xtime=Array(256),i=0;128>i;++i)xtime[i]=i<<1,xtime[i+128]=i+128<<1^283;sbox=Array(256);isbox=Array(256);mix=Array(4);imix=Array(4);for(i=0;4>i;++i)mix[i]=Array(256),imix[i]=Array(256);var e=0,ei=0;for(i=0;256>
i;++i){var sx=ei^ei<<1^ei<<2^ei<<3^ei<<4;sx=sx>>8^sx&255^99;sbox[e]=sx;isbox[sx]=e;var sx2=xtime[sx];var e2=xtime[e];var e4=xtime[e2];var e8=xtime[e4];sx2^=sx2<<24^sx<<16^sx<<8^sx;e4=(e2^e4^e8)<<24^(e^e8)<<16^(e^e4^e8)<<8^e^e2^e8;for(var n=0;4>n;++n)mix[n][e]=sx2,imix[n][sx]=e4,sx2=sx2<<24|sx2>>>8,e4=e4<<24|e4>>>8;0===e?e=ei=1:(e=e2^xtime[xtime[xtime[e2^e8]]],ei^=xtime[xtime[ei]])}}function _expandKey(key,decrypt){key=key.slice(0);for(var temp,iNk=1,Nk=key.length,end=Nb*(Nk+6+1),i=Nk;i<end;++i)temp=
key[i-1],0===i%Nk?(temp=sbox[temp>>>16&255]<<24^sbox[temp>>>8&255]<<16^sbox[temp&255]<<8^sbox[temp>>>24]^rcon[iNk]<<24,iNk++):6<Nk&&4===i%Nk&&(temp=sbox[temp>>>24]<<24^sbox[temp>>>16&255]<<16^sbox[temp>>>8&255]<<8^sbox[temp&255]),key[i]=key[i-Nk]^temp;if(decrypt){temp=imix[0];iNk=imix[1];Nk=imix[2];var m3=imix[3],wnew=key.slice(0);end=key.length;i=0;for(var wi=end-Nb;i<end;i+=Nb,wi-=Nb)if(0===i||i===end-Nb)wnew[i]=key[wi],wnew[i+1]=key[wi+3],wnew[i+2]=key[wi+2],wnew[i+3]=key[wi+1];else for(var n=
0;n<Nb;++n)decrypt=key[wi+n],wnew[i+(3&-n)]=temp[sbox[decrypt>>>24]]^iNk[sbox[decrypt>>>16&255]]^Nk[sbox[decrypt>>>8&255]]^m3[sbox[decrypt&255]];key=wnew}return key}function _updateBlock(w,input,output,decrypt){var Nr=w.length/4-1;if(decrypt){var m0=imix[0];var m1=imix[1];var m2=imix[2];var m3=imix[3];var sub=isbox}else m0=mix[0],m1=mix[1],m2=mix[2],m3=mix[3],sub=sbox;var a=input[0]^w[0];var b=input[decrypt?3:1]^w[1];var c=input[2]^w[2];input=input[decrypt?1:3]^w[3];for(var i=3,round=1;round<Nr;++round){var a2=
m0[a>>>24]^m1[b>>>16&255]^m2[c>>>8&255]^m3[input&255]^w[++i];var b2=m0[b>>>24]^m1[c>>>16&255]^m2[input>>>8&255]^m3[a&255]^w[++i];var c2=m0[c>>>24]^m1[input>>>16&255]^m2[a>>>8&255]^m3[b&255]^w[++i];input=m0[input>>>24]^m1[a>>>16&255]^m2[b>>>8&255]^m3[c&255]^w[++i];a=a2;b=b2;c=c2}output[0]=sub[a>>>24]<<24^sub[b>>>16&255]<<16^sub[c>>>8&255]<<8^sub[input&255]^w[++i];output[decrypt?3:1]=sub[b>>>24]<<24^sub[c>>>16&255]<<16^sub[input>>>8&255]<<8^sub[a&255]^w[++i];output[2]=sub[c>>>24]<<24^sub[input>>>16&
255]<<16^sub[a>>>8&255]<<8^sub[b&255]^w[++i];output[decrypt?1:3]=sub[input>>>24]<<24^sub[a>>>16&255]<<16^sub[b>>>8&255]<<8^sub[c&255]^w[++i]}function _createCipher(options$jscomp$0){options$jscomp$0=options$jscomp$0||{};var algorithm="AES-"+(options$jscomp$0.mode||"CBC").toUpperCase();var cipher=options$jscomp$0.decrypt?forge.cipher.createDecipher(algorithm,options$jscomp$0.key):forge.cipher.createCipher(algorithm,options$jscomp$0.key);var start=cipher.start;cipher.start=function(iv,options){var output=
null;options instanceof forge.util.ByteBuffer&&(output=options,options={});options=options||{};options.output=output;options.iv=iv;start.call(cipher,options)};return cipher}var forge=require("module$node_modules$node_forge$lib$forge");require("module$node_modules$node_forge$lib$cipher");require("module$node_modules$node_forge$lib$cipherModes");require("module$node_modules$node_forge$lib$util");module.exports=forge.aes=forge.aes||{};forge.aes.startEncrypting=function(key,iv,output,mode){key=_createCipher({key:key,
output:output,decrypt:!1,mode:mode});key.start(iv);return key};forge.aes.createEncryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:!1,mode:mode})};forge.aes.startDecrypting=function(key,iv,output,mode){key=_createCipher({key:key,output:output,decrypt:!0,mode:mode});key.start(iv);return key};forge.aes.createDecryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:!0,mode:mode})};forge.aes.Algorithm=function(name,mode){init||initialize();
var self=this;self.name=name;self.mode=new mode({blockSize:16,cipher:{encrypt:function(inBlock,outBlock){return _updateBlock(self._w,inBlock,outBlock,!1)},decrypt:function(inBlock,outBlock){return _updateBlock(self._w,inBlock,outBlock,!0)}}});self._init=!1};forge.aes.Algorithm.prototype.initialize=function(options){if(!this._init){var key=options.key;if("string"===typeof key&&(16===key.length||24===key.length||32===key.length))key=forge.util.createBuffer(key);else if(forge.util.isArray(key)&&(16===
key.length||24===key.length||32===key.length)){var tmp=key;key=forge.util.createBuffer();for(var i=0;i<tmp.length;++i)key.putByte(tmp[i])}if(!forge.util.isArray(key)){tmp=key;key=[];var len=tmp.length();if(16===len||24===len||32===len)for(len>>>=2,i=0;i<len;++i)key.push(tmp.getInt32())}if(!forge.util.isArray(key)||4!==key.length&&6!==key.length&&8!==key.length)throw Error("Invalid key parameter.");tmp=-1!==["CFB","OFB","CTR","GCM"].indexOf(this.mode.name);this._w=_expandKey(key,options.decrypt&&!tmp);
this._init=!0}};forge.aes._expandKey=function(key,decrypt){init||initialize();return _expandKey(key,decrypt)};forge.aes._updateBlock=_updateBlock;registerAlgorithm("AES-ECB",forge.cipher.modes.ecb);registerAlgorithm("AES-CBC",forge.cipher.modes.cbc);registerAlgorithm("AES-CFB",forge.cipher.modes.cfb);registerAlgorithm("AES-OFB",forge.cipher.modes.ofb);registerAlgorithm("AES-CTR",forge.cipher.modes.ctr);registerAlgorithm("AES-GCM",forge.cipher.modes.gcm);var init=!1,Nb=4,sbox,isbox,rcon,mix,imix}
//# sourceMappingURL=module$node_modules$node_forge$lib$aes.js.map
