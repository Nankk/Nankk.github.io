shadow$provide.module$node_modules$jwa$index=function(global,require,module,exports){function checkIsPublicKey(key){if(!Buffer.isBuffer(key)&&"string"!==typeof key){if(!supportsKeyObjects)throw typeError(MSG_INVALID_VERIFIER_KEY);if("object"!==typeof key)throw typeError(MSG_INVALID_VERIFIER_KEY);if("string"!==typeof key.type)throw typeError(MSG_INVALID_VERIFIER_KEY);if("string"!==typeof key.asymmetricKeyType)throw typeError(MSG_INVALID_VERIFIER_KEY);if("function"!==typeof key.export)throw typeError(MSG_INVALID_VERIFIER_KEY);
}}function checkIsPrivateKey(key){if(!Buffer.isBuffer(key)&&"string"!==typeof key&&"object"!==typeof key)throw typeError("key must be a string, a buffer or an object");}function fromBase64(base64){return base64.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function toBase64(base64url){base64url=base64url.toString();var padding=4-base64url.length%4;if(4!==padding)for(var i=0;i<padding;++i)base64url+="\x3d";return base64url.replace(/\-/g,"+").replace(/_/g,"/")}function typeError(template){var args=
[].slice.call(arguments,1);args=util.format.bind(util,template).apply(null,args);return new TypeError(args)}function normalizeInput(thing){var obj=thing;Buffer.isBuffer(obj)||"string"===typeof obj||(thing=JSON.stringify(thing));return thing}function createHmacSigner(bits){return function(thing,secret){if(!Buffer.isBuffer(secret)&&"string"!==typeof secret){if(!supportsKeyObjects)throw typeError(MSG_INVALID_SECRET);if("object"!==typeof secret)throw typeError(MSG_INVALID_SECRET);if("secret"!==secret.type)throw typeError(MSG_INVALID_SECRET);
if("function"!==typeof secret.export)throw typeError(MSG_INVALID_SECRET);}thing=normalizeInput(thing);secret=crypto.createHmac("sha"+bits,secret);thing=(secret.update(thing),secret.digest("base64"));return fromBase64(thing)}}function createHmacVerifier(bits){return function(thing,signature,secret){thing=createHmacSigner(bits)(thing,secret);return bufferEqual(Buffer.from(signature),Buffer.from(thing))}}function createKeySigner(bits){return function(thing,privateKey){checkIsPrivateKey(privateKey);thing=
normalizeInput(thing);var signer=crypto.createSign("RSA-SHA"+bits);thing=(signer.update(thing),signer.sign(privateKey,"base64"));return fromBase64(thing)}}function createKeyVerifier(bits){return function(thing,signature,publicKey){checkIsPublicKey(publicKey);thing=normalizeInput(thing);signature=toBase64(signature);var verifier=crypto.createVerify("RSA-SHA"+bits);verifier.update(thing);return verifier.verify(publicKey,signature,"base64")}}function createPSSKeySigner(bits){return function(thing,privateKey){checkIsPrivateKey(privateKey);
thing=normalizeInput(thing);var signer=crypto.createSign("RSA-SHA"+bits);thing=(signer.update(thing),signer.sign({key:privateKey,padding:crypto.constants.RSA_PKCS1_PSS_PADDING,saltLength:crypto.constants.RSA_PSS_SALTLEN_DIGEST},"base64"));return fromBase64(thing)}}function createPSSKeyVerifier(bits){return function(thing,signature,publicKey){checkIsPublicKey(publicKey);thing=normalizeInput(thing);signature=toBase64(signature);var verifier=crypto.createVerify("RSA-SHA"+bits);verifier.update(thing);
return verifier.verify({key:publicKey,padding:crypto.constants.RSA_PKCS1_PSS_PADDING,saltLength:crypto.constants.RSA_PSS_SALTLEN_DIGEST},signature,"base64")}}function createECDSASigner(bits){var inner=createKeySigner(bits);return function(){var signature=inner.apply(null,arguments);return signature=formatEcdsa.derToJose(signature,"ES"+bits)}}function createECDSAVerifer(bits){var inner=createKeyVerifier(bits);return function(thing,signature,publicKey){signature=formatEcdsa.joseToDer(signature,"ES"+
bits).toString("base64");return inner(thing,signature,publicKey)}}function createNoneSigner(){return function(){return""}}function createNoneVerifier(){return function(thing,signature){return""===signature}}var bufferEqual=require("module$node_modules$buffer_equal_constant_time$index"),Buffer=require("module$node_modules$safe_buffer$index").Buffer,crypto=require("module$node_modules$crypto_browserify$index"),formatEcdsa=require("module$node_modules$ecdsa_sig_formatter$src$ecdsa_sig_formatter"),util=
require("module$node_modules$util$util"),MSG_INVALID_SECRET="secret must be a string or buffer",MSG_INVALID_VERIFIER_KEY="key must be a string or a buffer",supportsKeyObjects="function"===typeof crypto.createPublicKey;supportsKeyObjects&&(MSG_INVALID_VERIFIER_KEY+=" or a KeyObject",MSG_INVALID_SECRET+="or a KeyObject");module.exports=function(algorithm){var signerFactories={hs:createHmacSigner,rs:createKeySigner,ps:createPSSKeySigner,es:createECDSASigner,none:createNoneSigner},verifierFactories={hs:createHmacVerifier,
rs:createKeyVerifier,ps:createPSSKeyVerifier,es:createECDSAVerifer,none:createNoneVerifier},match=algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);if(!match)throw typeError('"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".',algorithm);algorithm=(match[1]||match[3]).toLowerCase();match=match[2];return{sign:signerFactories[algorithm](match),verify:verifierFactories[algorithm](match)}}}
//# sourceMappingURL=module$node_modules$jwa$index.js.map
