shadow$provide.module$node_modules$node_forge$lib$pkcs12=function(global,require,module,exports){function _getBagsByAttribute(safeContents,attrName,attrValue,bagType){for(var result=[],i=0;i<safeContents.length;i++)for(var j=0;j<safeContents[i].safeBags.length;j++){var bag=safeContents[i].safeBags[j];if(void 0===bagType||bag.type===bagType)null===attrName?result.push(bag):void 0!==bag.attributes[attrName]&&0<=bag.attributes[attrName].indexOf(attrValue)&&result.push(bag)}return result}function _decodePkcs7Data(data){if(data.composed||
data.constructed){for(var value=forge.util.createBuffer(),i=0;i<data.value.length;++i)value.putBytes(data.value[i].value);data.composed=data.constructed=!1;data.value=value.getBytes()}return data}function _decodeAuthenticatedSafe(pfx,authSafe,strict,password$jscomp$0){authSafe=asn1.fromDer(authSafe,strict);if(authSafe.tagClass!==asn1.Class.UNIVERSAL||authSafe.type!==asn1.Type.SEQUENCE||!0!==authSafe.constructed)throw Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");for(var i=
0;i<authSafe.value.length;i++){var capture={},errors=[];if(!asn1.validate(authSafe.value[i],contentInfoValidator,capture,errors))throw pfx=Error("Cannot read ContentInfo."),pfx.errors=errors,pfx;errors={encrypted:!1};var data=capture.content.value[0];switch(asn1.derToOid(capture.contentType)){case pki.oids.data:if(data.tagClass!==asn1.Class.UNIVERSAL||data.type!==asn1.Type.OCTETSTRING)throw Error("PKCS#12 SafeContents Data is not an OCTET STRING.");capture=_decodePkcs7Data(data).value;break;case pki.oids.encryptedData:var password=
password$jscomp$0;capture={};var errors$jscomp$0=[];if(!asn1.validate(data,forge.pkcs7.asn1.encryptedDataValidator,capture,errors$jscomp$0))throw pfx=Error("Cannot read EncryptedContentInfo."),pfx.errors=errors$jscomp$0,pfx;data=asn1.derToOid(capture.contentType);if(data!==pki.oids.data)throw pfx=Error("PKCS#12 EncryptedContentInfo ContentType is not Data."),pfx.oid=data,pfx;data=asn1.derToOid(capture.encAlgorithm);data=pki.pbe.getCipher(data,capture.encParameter,password);capture=_decodePkcs7Data(capture.encryptedContentAsn1);
capture=forge.util.createBuffer(capture.value);data.update(capture);if(!data.finish())throw Error("Failed to decrypt PKCS#12 SafeContents.");capture=data.output.getBytes();errors.encrypted=!0;break;default:throw pfx=Error("Unsupported PKCS#12 contentType."),pfx.contentType=asn1.derToOid(capture.contentType),pfx;}errors.safeBags=_decodeSafeContents(capture,strict,password$jscomp$0);pfx.safeContents.push(errors)}}function _decodeSafeContents(safeContents,strict,password){if(!strict&&0===safeContents.length)return[];
safeContents=asn1.fromDer(safeContents,strict);if(safeContents.tagClass!==asn1.Class.UNIVERSAL||safeContents.type!==asn1.Type.SEQUENCE||!0!==safeContents.constructed)throw Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.");for(var res=[],i=0;i<safeContents.value.length;i++){var capture={},errors=[];if(!asn1.validate(safeContents.value[i],safeBagValidator,capture,errors))throw safeContents=Error("Cannot read SafeBag."),safeContents.errors=errors,safeContents;var bag={type:asn1.derToOid(capture.bagId),
attributes:_decodeBagAttributes(capture.bagAttributes)};res.push(bag);var bagAsn1=capture.bagValue.value[0];switch(bag.type){case pki.oids.pkcs8ShroudedKeyBag:if(bagAsn1=pki.decryptPrivateKeyInfo(bagAsn1,password),null===bagAsn1)throw Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?");case pki.oids.keyBag:try{bag.key=pki.privateKeyFromAsn1(bagAsn1)}catch(e){bag.key=null,bag.asn1=bagAsn1}continue;case pki.oids.certBag:var validator=certBagValidator;var decoder=function(){if(asn1.derToOid(capture.certId)!==
pki.oids.x509Certificate){var error=Error("Unsupported certificate type, only X.509 supported.");error.oid=asn1.derToOid(capture.certId);throw error;}error=asn1.fromDer(capture.cert,strict);try{bag.cert=pki.certificateFromAsn1(error,!0)}catch(e$18){bag.cert=null,bag.asn1=error}};break;default:throw safeContents=Error("Unsupported PKCS#12 SafeBag type."),safeContents.oid=bag.type,safeContents;}if(void 0!==validator&&!asn1.validate(bagAsn1,validator,capture,errors))throw safeContents=Error("Cannot read PKCS#12 "+
validator.name),safeContents.errors=errors,safeContents;decoder()}return res}function _decodeBagAttributes(attributes){var decodedAttrs={};if(void 0!==attributes)for(var i=0;i<attributes.length;++i){var capture={},errors=[];if(!asn1.validate(attributes[i],attributeValidator,capture,errors))throw attributes=Error("Cannot read PKCS#12 BagAttribute."),attributes.errors=errors,attributes;errors=asn1.derToOid(capture.oid);if(void 0!==pki.oids[errors]){decodedAttrs[pki.oids[errors]]=[];for(var j=0;j<capture.values.length;++j)decodedAttrs[pki.oids[errors]].push(capture.values[j].value)}}return decodedAttrs}
var forge=require("module$node_modules$node_forge$lib$forge");require("module$node_modules$node_forge$lib$asn1");require("module$node_modules$node_forge$lib$hmac");require("module$node_modules$node_forge$lib$oids");require("module$node_modules$node_forge$lib$pkcs7asn1");require("module$node_modules$node_forge$lib$pbe");require("module$node_modules$node_forge$lib$random");require("module$node_modules$node_forge$lib$rsa");require("module$node_modules$node_forge$lib$sha1");require("module$node_modules$node_forge$lib$util");
require("module$node_modules$node_forge$lib$x509");var asn1=forge.asn1,pki=forge.pki,p12=module.exports=forge.pkcs12=forge.pkcs12||{},contentInfoValidator={name:"ContentInfo",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"ContentInfo.contentType",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"contentType"},{name:"ContentInfo.content",tagClass:asn1.Class.CONTEXT_SPECIFIC,constructed:!0,captureAsn1:"content"}]},pfxValidator={name:"PFX",tagClass:asn1.Class.UNIVERSAL,
type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"PFX.version",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,capture:"version"},contentInfoValidator,{name:"PFX.macData",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,optional:!0,captureAsn1:"mac",value:[{name:"PFX.macData.mac",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"PFX.macData.mac.digestAlgorithm",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,
value:[{name:"PFX.macData.mac.digestAlgorithm.algorithm",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"macAlgorithm"},{name:"PFX.macData.mac.digestAlgorithm.parameters",tagClass:asn1.Class.UNIVERSAL,captureAsn1:"macAlgorithmParameters"}]},{name:"PFX.macData.mac.digest",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:!1,capture:"macDigest"}]},{name:"PFX.macData.macSalt",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:!1,capture:"macSalt"},
{name:"PFX.macData.iterations",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,optional:!0,capture:"macIterations"}]}]},safeBagValidator={name:"SafeBag",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"SafeBag.bagId",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"bagId"},{name:"SafeBag.bagValue",tagClass:asn1.Class.CONTEXT_SPECIFIC,constructed:!0,captureAsn1:"bagValue"},{name:"SafeBag.bagAttributes",tagClass:asn1.Class.UNIVERSAL,
type:asn1.Type.SET,constructed:!0,optional:!0,capture:"bagAttributes"}]},attributeValidator={name:"Attribute",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"Attribute.attrId",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"oid"},{name:"Attribute.attrValues",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:!0,capture:"values"}]},certBagValidator={name:"CertBag",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,
value:[{name:"CertBag.certId",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"certId"},{name:"CertBag.certValue",tagClass:asn1.Class.CONTEXT_SPECIFIC,constructed:!0,value:[{name:"CertBag.certValue[0]",tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.OCTETSTRING,constructed:!1,capture:"cert"}]}]};p12.pkcs12FromAsn1=function(obj,strict,password){"string"===typeof strict?(password=strict,strict=!0):void 0===strict&&(strict=!0);var capture={};if(!asn1.validate(obj,pfxValidator,capture,
[]))throw strict=Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX."),strict.errors=strict,strict;var pfx={version:capture.version.charCodeAt(0),safeContents:[],getBags:function(filter){var rval={},localKeyId;"localKeyId"in filter?localKeyId=filter.localKeyId:"localKeyIdHex"in filter&&(localKeyId=forge.util.hexToBytes(filter.localKeyIdHex));void 0===localKeyId&&!("friendlyName"in filter)&&"bagType"in filter&&(rval[filter.bagType]=_getBagsByAttribute(pfx.safeContents,null,null,filter.bagType));
void 0!==localKeyId&&(rval.localKeyId=_getBagsByAttribute(pfx.safeContents,"localKeyId",localKeyId,filter.bagType));"friendlyName"in filter&&(rval.friendlyName=_getBagsByAttribute(pfx.safeContents,"friendlyName",filter.friendlyName,filter.bagType));return rval},getBagsByFriendlyName:function(friendlyName,bagType){return _getBagsByAttribute(pfx.safeContents,"friendlyName",friendlyName,bagType)},getBagsByLocalKeyId:function(localKeyId,bagType){return _getBagsByAttribute(pfx.safeContents,"localKeyId",
localKeyId,bagType)}};if(3!==capture.version.charCodeAt(0))throw strict=Error("PKCS#12 PFX of version other than 3 not supported."),strict.version=capture.version.charCodeAt(0),strict;if(asn1.derToOid(capture.contentType)!==pki.oids.data)throw strict=Error("Only PKCS#12 PFX in password integrity mode supported."),strict.oid=asn1.derToOid(capture.contentType),strict;obj=capture.content.value[0];if(obj.tagClass!==asn1.Class.UNIVERSAL||obj.type!==asn1.Type.OCTETSTRING)throw Error("PKCS#12 authSafe content data is not an OCTET STRING.");
obj=_decodePkcs7Data(obj);if(capture.mac){var md=null,macKeyBytes=0,macAlgorithm=asn1.derToOid(capture.macAlgorithm);switch(macAlgorithm){case pki.oids.sha1:md=forge.md.sha1.create();macKeyBytes=20;break;case pki.oids.sha256:md=forge.md.sha256.create();macKeyBytes=32;break;case pki.oids.sha384:md=forge.md.sha384.create();macKeyBytes=48;break;case pki.oids.sha512:md=forge.md.sha512.create();macKeyBytes=64;break;case pki.oids.md5:md=forge.md.md5.create(),macKeyBytes=16}if(null===md)throw Error("PKCS#12 uses unsupported MAC algorithm: "+
macAlgorithm);macAlgorithm=new forge.util.ByteBuffer(capture.macSalt);var macIterations="macIterations"in capture?parseInt(forge.util.bytesToHex(capture.macIterations),16):1;macKeyBytes=p12.generateKey(password,macAlgorithm,3,macIterations,macKeyBytes,md);macAlgorithm=forge.hmac.create();macAlgorithm.start(md,macKeyBytes);macAlgorithm.update(obj.value);if(macAlgorithm.getMac().getBytes()!==capture.macDigest)throw Error("PKCS#12 MAC could not be verified. Invalid password?");}_decodeAuthenticatedSafe(pfx,
obj.value,strict,password);return pfx};p12.toPkcs12Asn1=function(key,cert,password,options){options=options||{};options.saltSize=options.saltSize||8;options.count=options.count||2048;options.algorithm=options.algorithm||options.encAlgorithm||"aes128";"useMac"in options||(options.useMac=!0);"localKeyId"in options||(options.localKeyId=null);"generateLocalKeyId"in options||(options.generateLocalKeyId=!0);var localKeyId=options.localKeyId,bagAttrs;if(null!==localKeyId)localKeyId=forge.util.hexToBytes(localKeyId);
else if(options.generateLocalKeyId)if(cert){var pairedCert=forge.util.isArray(cert)?cert[0]:cert;"string"===typeof pairedCert&&(pairedCert=pki.certificateFromPem(pairedCert));localKeyId=forge.md.sha1.create();localKeyId.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());localKeyId=localKeyId.digest().getBytes()}else localKeyId=forge.random.getBytes(20);pairedCert=[];null!==localKeyId&&pairedCert.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,
asn1.Type.OID,!1,asn1.oidToDer(pki.oids.localKeyId).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,localKeyId)])]));"friendlyName"in options&&pairedCert.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(pki.oids.friendlyName).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BMPSTRING,!1,options.friendlyName)])]));
0<pairedCert.length&&(bagAttrs=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,!0,pairedCert));localKeyId=[];pairedCert=[];null!==cert&&(pairedCert=forge.util.isArray(cert)?cert:[cert]);for(var certSafeBags=[],i=0;i<pairedCert.length;++i){cert=pairedCert[i];"string"===typeof cert&&(cert=pki.certificateFromPem(cert));var certBagAttrs=0===i?bagAttrs:void 0;cert=pki.certificateToAsn1(cert);cert=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(pki.oids.certBag).getBytes()),
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(pki.oids.x509Certificate).getBytes()),asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,asn1.toDer(cert).getBytes())])])]),certBagAttrs]);certSafeBags.push(cert)}0<certSafeBags.length&&(cert=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,certSafeBags),cert=asn1.create(asn1.Class.UNIVERSAL,
asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(pki.oids.data).getBytes()),asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,asn1.toDer(cert).getBytes())])]),localKeyId.push(cert));null!==key&&(key=pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key)),key=null===password?asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(pki.oids.keyBag).getBytes()),
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,!0,[key]),bagAttrs]):asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,!0,[pki.encryptPrivateKeyInfo(key,password,options)]),bagAttrs]),key=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[key]),key=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,
!1,asn1.oidToDer(pki.oids.data).getBytes()),asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,asn1.toDer(key).getBytes())])]),localKeyId.push(key));bagAttrs=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,localKeyId);if(options.useMac){localKeyId=forge.md.sha1.create();var macData=new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize));options=options.count;key=p12.generateKey(password,macData,3,options,20);password=forge.hmac.create();
password.start(localKeyId,key);password.update(asn1.toDer(bagAttrs).getBytes());password=password.getMac();macData=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(pki.oids.sha1).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,!1,"")]),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,password.getBytes())]),
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,macData.getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,asn1.integerToDer(options).getBytes())])}return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,asn1.integerToDer(3).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(pki.oids.data).getBytes()),asn1.create(asn1.Class.CONTEXT_SPECIFIC,
0,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,asn1.toDer(bagAttrs).getBytes())])]),macData])};p12.generateKey=forge.pbe.generatePkcs12Key}
//# sourceMappingURL=module$node_modules$node_forge$lib$pkcs12.js.map
