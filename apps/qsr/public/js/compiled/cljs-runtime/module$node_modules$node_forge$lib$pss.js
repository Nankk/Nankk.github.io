shadow$provide.module$node_modules$node_forge$lib$pss=function(global,require,module,exports){var forge=require("module$node_modules$node_forge$lib$forge");require("module$node_modules$node_forge$lib$random");require("module$node_modules$node_forge$lib$util");(module.exports=forge.pss=forge.pss||{}).create=function(options){3===arguments.length&&(options={md:arguments[0],mgf:arguments[1],saltLength:arguments[2]});var hash=options.md,mgf=options.mgf,hLen=hash.digestLength,salt_=options.salt||null;
"string"===typeof salt_&&(salt_=forge.util.createBuffer(salt_));if("saltLength"in options)var sLen=options.saltLength;else if(null!==salt_)sLen=salt_.length();else throw Error("Salt length not specified or specific salt not given.");if(null!==salt_&&salt_.length()!==sLen)throw Error("Given salt length does not match length of given salt.");var prng=options.prng||forge.random;return{encode:function(md,modBits){--modBits;var emLen=Math.ceil(modBits/8);md=md.digest().getBytes();if(emLen<hLen+sLen+2)throw Error("Message is too long to encrypt.");
var salt=null===salt_?prng.getBytesSync(sLen):salt_.bytes();var i=new forge.util.ByteBuffer;i.fillWithByte(0,8);i.putBytes(md);i.putBytes(salt);hash.start();hash.update(i.getBytes());md=hash.digest().getBytes();i=new forge.util.ByteBuffer;i.fillWithByte(0,emLen-sLen-hLen-2);i.putByte(1);i.putBytes(salt);var db=i.getBytes(),maskLen=emLen-hLen-1,dbMask=mgf.generate(md,maskLen);salt="";for(i=0;i<maskLen;i++)salt+=String.fromCharCode(db.charCodeAt(i)^dbMask.charCodeAt(i));modBits=65280>>8*emLen-modBits&
255;salt=String.fromCharCode(salt.charCodeAt(0)&~modBits)+salt.substr(1);return salt+md+String.fromCharCode(188)},verify:function(mHash,em,modBits){var i=modBits-1;modBits=Math.ceil(i/8);em=em.substr(-modBits);if(modBits<hLen+sLen+2)throw Error("Inconsistent parameters to PSS signature verification.");if(188!==em.charCodeAt(modBits-1))throw Error("Encoded message does not end in 0xBC.");var maskLen=modBits-hLen-1,maskedDB=em.substr(0,maskLen);em=em.substr(maskLen,hLen);var mask=65280>>8*modBits-i&
255;if(0!==(maskedDB.charCodeAt(0)&mask))throw Error("Bits beyond keysize not zero as expected.");var dbMask=mgf.generate(em,maskLen),db="";for(i=0;i<maskLen;i++)db+=String.fromCharCode(maskedDB.charCodeAt(i)^dbMask.charCodeAt(i));db=String.fromCharCode(db.charCodeAt(0)&~mask)+db.substr(1);modBits=modBits-hLen-sLen-2;for(i=0;i<modBits;i++)if(0!==db.charCodeAt(i))throw Error("Leftmost octets not zero as expected");if(1!==db.charCodeAt(modBits))throw Error("Inconsistent PSS signature, 0x01 marker not found");
modBits=db.substr(-sLen);maskLen=new forge.util.ByteBuffer;maskLen.fillWithByte(0,8);maskLen.putBytes(mHash);maskLen.putBytes(modBits);hash.start();hash.update(maskLen.getBytes());mHash=hash.digest().getBytes();return em===mHash}}}}
//# sourceMappingURL=module$node_modules$node_forge$lib$pss.js.map
