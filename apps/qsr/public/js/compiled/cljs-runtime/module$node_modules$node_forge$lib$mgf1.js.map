{
"version":3,
"file":"module$node_modules$node_forge$lib$mgf1.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,wCAAA,CAA4D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAUpG,IAAIC,MAAQH,OAAA,CAAQ,0CAAR,CACZA,QAAA,CAAQ,yCAAR,CAEAG,MAAAC,IAAA,CAAYD,KAAAC,IAAZ,EAAyB,EAUzBC,EATWJ,MAAAC,QASXG,CAT4BF,KAAAC,IAAAE,KAS5BD,CAT6CF,KAAAG,KAS7CD,CAT0DF,KAAAG,KAS1DD,EATwE,EASxEA,QAAA,CAAcE,QAAQ,CAACC,EAAD,CAAK,CAiCzB,MAhCUJ,CAQRK,SAAUA,QAAQ,CAACC,IAAD,CAAOC,OAAP,CAAgB,CAMhC,IAJA,IAAIC,EAAI,IAAIT,KAAAU,KAAAC,WAAZ,CAGIC,IAAMC,IAAAC,KAAA,CAAUN,OAAV,CAAoBH,EAAAU,aAApB,CAHV,CAIQC,EAAI,CAAZ,CAAeA,CAAf,CAAmBJ,GAAnB,CAAwBI,CAAA,EAAxB,CAA6B,CAE3B,IAAIC,EAAI,IAAIjB,KAAAU,KAAAC,WACZM,EAAAC,SAAA,CAAWF,CAAX,CAIAX,GAAAc,MAAA,EACAd,GAAAe,OAAA,CAAUb,IAAV;AAAiBU,CAAAI,SAAA,EAAjB,CACAZ,EAAAa,UAAA,CAAYjB,EAAAkB,OAAA,EAAZ,CAT2B,CAa7Bd,CAAAe,SAAA,CAAWf,CAAAgB,OAAA,EAAX,CAAwBjB,OAAxB,CACA,OAAOC,EAAAY,SAAA,EApByB,CAR1BpB,CADe,CAvByE;",
"sources":["node_modules/node-forge/lib/mgf1.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$node_forge$lib$mgf1\"] = function(global,require,module,exports) {\n/**\n * Javascript implementation of mask generation function MGF1.\n *\n * @author Stefan Siegl\n * @author Dave Longley\n *\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n * Copyright (c) 2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\n\nforge.mgf = forge.mgf || {};\nvar mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};\n\n/**\n * Creates a MGF1 mask generation function object.\n *\n * @param md the message digest API to use (eg: forge.md.sha1.create()).\n *\n * @return a mask generation function object.\n */\nmgf1.create = function(md) {\n  var mgf = {\n    /**\n     * Generate mask of specified length.\n     *\n     * @param {String} seed The seed for mask generation.\n     * @param maskLen Number of bytes to generate.\n     * @return {String} The generated mask.\n     */\n    generate: function(seed, maskLen) {\n      /* 2. Let T be the empty octet string. */\n      var t = new forge.util.ByteBuffer();\n\n      /* 3. For counter from 0 to ceil(maskLen / hLen), do the following: */\n      var len = Math.ceil(maskLen / md.digestLength);\n      for(var i = 0; i < len; i++) {\n        /* a. Convert counter to an octet string C of length 4 octets */\n        var c = new forge.util.ByteBuffer();\n        c.putInt32(i);\n\n        /* b. Concatenate the hash of the seed mgfSeed and C to the octet\n         * string T: */\n        md.start();\n        md.update(seed + c.getBytes());\n        t.putBuffer(md.digest());\n      }\n\n      /* Output the leading maskLen octets of T as the octet string mask. */\n      t.truncate(t.length() - maskLen);\n      return t.getBytes();\n    }\n  };\n\n  return mgf;\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","forge","mgf","create","mgf1","mgf1.create","md","generate","seed","maskLen","t","util","ByteBuffer","len","Math","ceil","digestLength","i","c","putInt32","start","update","getBytes","putBuffer","digest","truncate","length"]
}
