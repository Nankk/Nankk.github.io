{
"version":3,
"file":"module$node_modules$node_forge$lib$random.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/node-forge/lib/random.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$node_forge$lib$random\"] = function(global,require,module,exports) {\n/**\n * An API for getting cryptographically-secure random bytes. The bytes are\n * generated using the Fortuna algorithm devised by Bruce Schneier and\n * Niels Ferguson.\n *\n * Getting strong random bytes is not yet easy to do in javascript. The only\n * truish random entropy that can be collected is from the mouse, keyboard, or\n * from timing with respect to page loads, etc. This generator makes a poor\n * attempt at providing random bytes when those sources haven't yet provided\n * enough entropy to initially seed or to reseed the PRNG.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2009-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./aes');\nrequire('./sha256');\nrequire('./prng');\nrequire('./util');\n\n(function() {\n\n// forge.random already defined\nif(forge.random && forge.random.getBytes) {\n  module.exports = forge.random;\n  return;\n}\n\n(function(jQuery) {\n\n// the default prng plugin, uses AES-128\nvar prng_aes = {};\nvar _prng_aes_output = new Array(4);\nvar _prng_aes_buffer = forge.util.createBuffer();\nprng_aes.formatKey = function(key) {\n  // convert the key into 32-bit integers\n  var tmp = forge.util.createBuffer(key);\n  key = new Array(4);\n  key[0] = tmp.getInt32();\n  key[1] = tmp.getInt32();\n  key[2] = tmp.getInt32();\n  key[3] = tmp.getInt32();\n\n  // return the expanded key\n  return forge.aes._expandKey(key, false);\n};\nprng_aes.formatSeed = function(seed) {\n  // convert seed into 32-bit integers\n  var tmp = forge.util.createBuffer(seed);\n  seed = new Array(4);\n  seed[0] = tmp.getInt32();\n  seed[1] = tmp.getInt32();\n  seed[2] = tmp.getInt32();\n  seed[3] = tmp.getInt32();\n  return seed;\n};\nprng_aes.cipher = function(key, seed) {\n  forge.aes._updateBlock(key, seed, _prng_aes_output, false);\n  _prng_aes_buffer.putInt32(_prng_aes_output[0]);\n  _prng_aes_buffer.putInt32(_prng_aes_output[1]);\n  _prng_aes_buffer.putInt32(_prng_aes_output[2]);\n  _prng_aes_buffer.putInt32(_prng_aes_output[3]);\n  return _prng_aes_buffer.getBytes();\n};\nprng_aes.increment = function(seed) {\n  // FIXME: do we care about carry or signed issues?\n  ++seed[3];\n  return seed;\n};\nprng_aes.md = forge.md.sha256;\n\n/**\n * Creates a new PRNG.\n */\nfunction spawnPrng() {\n  var ctx = forge.prng.create(prng_aes);\n\n  /**\n   * Gets random bytes. If a native secure crypto API is unavailable, this\n   * method tries to make the bytes more unpredictable by drawing from data that\n   * can be collected from the user of the browser, eg: mouse movement.\n   *\n   * If a callback is given, this method will be called asynchronously.\n   *\n   * @param count the number of random bytes to get.\n   * @param [callback(err, bytes)] called once the operation completes.\n   *\n   * @return the random bytes in a string.\n   */\n  ctx.getBytes = function(count, callback) {\n    return ctx.generate(count, callback);\n  };\n\n  /**\n   * Gets random bytes asynchronously. If a native secure crypto API is\n   * unavailable, this method tries to make the bytes more unpredictable by\n   * drawing from data that can be collected from the user of the browser,\n   * eg: mouse movement.\n   *\n   * @param count the number of random bytes to get.\n   *\n   * @return the random bytes in a string.\n   */\n  ctx.getBytesSync = function(count) {\n    return ctx.generate(count);\n  };\n\n  return ctx;\n}\n\n// create default prng context\nvar _ctx = spawnPrng();\n\n// add other sources of entropy only if window.crypto.getRandomValues is not\n// available -- otherwise this source will be automatically used by the prng\nvar getRandomValues = null;\nvar globalScope = forge.util.globalScope;\nvar _crypto = globalScope.crypto || globalScope.msCrypto;\nif(_crypto && _crypto.getRandomValues) {\n  getRandomValues = function(arr) {\n    return _crypto.getRandomValues(arr);\n  };\n}\n\nif(forge.options.usePureJavaScript ||\n  (!forge.util.isNodejs && !getRandomValues)) {\n  // if this is a web worker, do not use weak entropy, instead register to\n  // receive strong entropy asynchronously from the main thread\n  if(typeof window === 'undefined' || window.document === undefined) {\n    // FIXME:\n  }\n\n  // get load time entropy\n  _ctx.collectInt(+new Date(), 32);\n\n  // add some entropy from navigator object\n  if(typeof(navigator) !== 'undefined') {\n    var _navBytes = '';\n    for(var key in navigator) {\n      try {\n        if(typeof(navigator[key]) == 'string') {\n          _navBytes += navigator[key];\n        }\n      } catch(e) {\n        /* Some navigator keys might not be accessible, e.g. the geolocation\n          attribute throws an exception if touched in Mozilla chrome://\n          context.\n\n          Silently ignore this and just don't use this as a source of\n          entropy. */\n      }\n    }\n    _ctx.collect(_navBytes);\n    _navBytes = null;\n  }\n\n  // add mouse and keyboard collectors if jquery is available\n  if(jQuery) {\n    // set up mouse entropy capture\n    jQuery().mousemove(function(e) {\n      // add mouse coords\n      _ctx.collectInt(e.clientX, 16);\n      _ctx.collectInt(e.clientY, 16);\n    });\n\n    // set up keyboard entropy capture\n    jQuery().keypress(function(e) {\n      _ctx.collectInt(e.charCode, 8);\n    });\n  }\n}\n\n/* Random API */\nif(!forge.random) {\n  forge.random = _ctx;\n} else {\n  // extend forge.random with _ctx\n  for(var key in _ctx) {\n    forge.random[key] = _ctx[key];\n  }\n}\n\n// expose spawn PRNG\nforge.random.createInstance = spawnPrng;\n\nmodule.exports = forge.random;\n\n})(typeof(jQuery) !== 'undefined' ? jQuery : null);\n\n})();\n\n};"],
"names":["shadow$provide","global","require","module","exports","forge","random","getBytes","jQuery","spawnPrng","ctx","prng","create","prng_aes","ctx.getBytes","count","callback","generate","getBytesSync","ctx.getBytesSync","_prng_aes_output","Array","_prng_aes_buffer","util","createBuffer","formatKey","prng_aes.formatKey","key","tmp","getInt32","aes","_expandKey","formatSeed","prng_aes.formatSeed","seed","cipher","prng_aes.cipher","_updateBlock","putInt32","increment","prng_aes.increment","md","sha256","_ctx","getRandomValues","globalScope","_crypto","crypto","msCrypto","arr","options","usePureJavaScript","isNodejs","collectInt","Date","navigator","_navBytes","e","collect","mousemove","clientX","clientY","keypress","charCode","createInstance"]
}
