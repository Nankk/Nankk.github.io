shadow$provide.module$node_modules$node_forge$lib$kem=function(global,require,module,exports){function _createKDF(kdf,md,counterStart,digestLength){kdf.generate=function(x,length){for(var key=new forge.util.ByteBuffer,k=Math.ceil(length/digestLength)+counterStart,c=new forge.util.ByteBuffer,i=counterStart;i<k;++i){c.putInt32(i);md.start();md.update(x+c.getBytes());var hash=md.digest();key.putBytes(hash.getBytes(digestLength))}key.truncate(key.length()-length);return key.getBytes()}}var forge=require("module$node_modules$node_forge$lib$forge");
require("module$node_modules$node_forge$lib$util");require("module$node_modules$node_forge$lib$random");require("module$node_modules$node_forge$lib$jsbn");module.exports=forge.kem=forge.kem||{};var BigInteger=forge.jsbn.BigInteger;forge.kem.rsa={};forge.kem.rsa.create=function(kdf,options){options=options||{};var prng=options.prng||forge.random;return{encrypt:function(publicKey,keyLength){var byteLength=Math.ceil(publicKey.n.bitLength()/8);do var r=(new BigInteger(forge.util.bytesToHex(prng.getBytesSync(byteLength)),
16)).mod(publicKey.n);while(0>=r.compareTo(BigInteger.ONE));r=forge.util.hexToBytes(r.toString(16));byteLength-=r.length;0<byteLength&&(r=forge.util.fillString(String.fromCharCode(0),byteLength)+r);publicKey=publicKey.encrypt(r,"NONE");keyLength=kdf.generate(r,keyLength);return{encapsulation:publicKey,key:keyLength}},decrypt:function(privateKey,encapsulation,keyLength){privateKey=privateKey.decrypt(encapsulation,"NONE");return kdf.generate(privateKey,keyLength)}}};forge.kem.kdf1=function(md,digestLength){_createKDF(this,
md,0,digestLength||md.digestLength)};forge.kem.kdf2=function(md,digestLength){_createKDF(this,md,1,digestLength||md.digestLength)}}
//# sourceMappingURL=module$node_modules$node_forge$lib$kem.js.map
