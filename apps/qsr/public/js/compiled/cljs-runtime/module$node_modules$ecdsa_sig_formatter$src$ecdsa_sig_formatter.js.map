{
"version":3,
"file":"module$node_modules$ecdsa_sig_formatter$src$ecdsa_sig_formatter.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$ecdsa_sig_formatter$src$ecdsa_sig_formatter\"] = function(global,require,module,exports) {\n'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar getParamBytesForAlg = require('./param-bytes-for-alg');\n\nvar MAX_OCTET = 0x80,\n\tCLASS_UNIVERSAL = 0,\n\tPRIMITIVE_BIT = 0x20,\n\tTAG_SEQ = 0x10,\n\tTAG_INT = 0x02,\n\tENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6),\n\tENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);\n\nfunction base64Url(base64) {\n\treturn base64\n\t\t.replace(/=/g, '')\n\t\t.replace(/\\+/g, '-')\n\t\t.replace(/\\//g, '_');\n}\n\nfunction signatureAsBuffer(signature) {\n\tif (Buffer.isBuffer(signature)) {\n\t\treturn signature;\n\t} else if ('string' === typeof signature) {\n\t\treturn Buffer.from(signature, 'base64');\n\t}\n\n\tthrow new TypeError('ECDSA signature must be a Base64 string or a Buffer');\n}\n\nfunction derToJose(signature, alg) {\n\tsignature = signatureAsBuffer(signature);\n\tvar paramBytes = getParamBytesForAlg(alg);\n\n\t// the DER encoded param should at most be the param size, plus a padding\n\t// zero, since due to being a signed integer\n\tvar maxEncodedParamLength = paramBytes + 1;\n\n\tvar inputLength = signature.length;\n\n\tvar offset = 0;\n\tif (signature[offset++] !== ENCODED_TAG_SEQ) {\n\t\tthrow new Error('Could not find expected \"seq\"');\n\t}\n\n\tvar seqLength = signature[offset++];\n\tif (seqLength === (MAX_OCTET | 1)) {\n\t\tseqLength = signature[offset++];\n\t}\n\n\tif (inputLength - offset < seqLength) {\n\t\tthrow new Error('\"seq\" specified length of \"' + seqLength + '\", only \"' + (inputLength - offset) + '\" remaining');\n\t}\n\n\tif (signature[offset++] !== ENCODED_TAG_INT) {\n\t\tthrow new Error('Could not find expected \"int\" for \"r\"');\n\t}\n\n\tvar rLength = signature[offset++];\n\n\tif (inputLength - offset - 2 < rLength) {\n\t\tthrow new Error('\"r\" specified length of \"' + rLength + '\", only \"' + (inputLength - offset - 2) + '\" available');\n\t}\n\n\tif (maxEncodedParamLength < rLength) {\n\t\tthrow new Error('\"r\" specified length of \"' + rLength + '\", max of \"' + maxEncodedParamLength + '\" is acceptable');\n\t}\n\n\tvar rOffset = offset;\n\toffset += rLength;\n\n\tif (signature[offset++] !== ENCODED_TAG_INT) {\n\t\tthrow new Error('Could not find expected \"int\" for \"s\"');\n\t}\n\n\tvar sLength = signature[offset++];\n\n\tif (inputLength - offset !== sLength) {\n\t\tthrow new Error('\"s\" specified length of \"' + sLength + '\", expected \"' + (inputLength - offset) + '\"');\n\t}\n\n\tif (maxEncodedParamLength < sLength) {\n\t\tthrow new Error('\"s\" specified length of \"' + sLength + '\", max of \"' + maxEncodedParamLength + '\" is acceptable');\n\t}\n\n\tvar sOffset = offset;\n\toffset += sLength;\n\n\tif (offset !== inputLength) {\n\t\tthrow new Error('Expected to consume entire buffer, but \"' + (inputLength - offset) + '\" bytes remain');\n\t}\n\n\tvar rPadding = paramBytes - rLength,\n\t\tsPadding = paramBytes - sLength;\n\n\tvar dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);\n\n\tfor (offset = 0; offset < rPadding; ++offset) {\n\t\tdst[offset] = 0;\n\t}\n\tsignature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);\n\n\toffset = paramBytes;\n\n\tfor (var o = offset; offset < o + sPadding; ++offset) {\n\t\tdst[offset] = 0;\n\t}\n\tsignature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);\n\n\tdst = dst.toString('base64');\n\tdst = base64Url(dst);\n\n\treturn dst;\n}\n\nfunction countPadding(buf, start, stop) {\n\tvar padding = 0;\n\twhile (start + padding < stop && buf[start + padding] === 0) {\n\t\t++padding;\n\t}\n\n\tvar needsSign = buf[start + padding] >= MAX_OCTET;\n\tif (needsSign) {\n\t\t--padding;\n\t}\n\n\treturn padding;\n}\n\nfunction joseToDer(signature, alg) {\n\tsignature = signatureAsBuffer(signature);\n\tvar paramBytes = getParamBytesForAlg(alg);\n\n\tvar signatureBytes = signature.length;\n\tif (signatureBytes !== paramBytes * 2) {\n\t\tthrow new TypeError('\"' + alg + '\" signatures must be \"' + paramBytes * 2 + '\" bytes, saw \"' + signatureBytes + '\"');\n\t}\n\n\tvar rPadding = countPadding(signature, 0, paramBytes);\n\tvar sPadding = countPadding(signature, paramBytes, signature.length);\n\tvar rLength = paramBytes - rPadding;\n\tvar sLength = paramBytes - sPadding;\n\n\tvar rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;\n\n\tvar shortLength = rsBytes < MAX_OCTET;\n\n\tvar dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);\n\n\tvar offset = 0;\n\tdst[offset++] = ENCODED_TAG_SEQ;\n\tif (shortLength) {\n\t\t// Bit 8 has value \"0\"\n\t\t// bits 7-1 give the length.\n\t\tdst[offset++] = rsBytes;\n\t} else {\n\t\t// Bit 8 of first octet has value \"1\"\n\t\t// bits 7-1 give the number of additional length octets.\n\t\tdst[offset++] = MAX_OCTET\t| 1;\n\t\t// length, base 256\n\t\tdst[offset++] = rsBytes & 0xff;\n\t}\n\tdst[offset++] = ENCODED_TAG_INT;\n\tdst[offset++] = rLength;\n\tif (rPadding < 0) {\n\t\tdst[offset++] = 0;\n\t\toffset += signature.copy(dst, offset, 0, paramBytes);\n\t} else {\n\t\toffset += signature.copy(dst, offset, rPadding, paramBytes);\n\t}\n\tdst[offset++] = ENCODED_TAG_INT;\n\tdst[offset++] = sLength;\n\tif (sPadding < 0) {\n\t\tdst[offset++] = 0;\n\t\tsignature.copy(dst, offset, paramBytes);\n\t} else {\n\t\tsignature.copy(dst, offset, paramBytes + sPadding);\n\t}\n\n\treturn dst;\n}\n\nmodule.exports = {\n\tderToJose: derToJose,\n\tjoseToDer: joseToDer\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","signatureAsBuffer","signature","Buffer","isBuffer","from","TypeError","countPadding","buf","start","stop","padding","MAX_OCTET","getParamBytesForAlg","derToJose","alg","paramBytes","maxEncodedParamLength","inputLength","length","offset","ENCODED_TAG_SEQ","Error","seqLength","ENCODED_TAG_INT","rLength","rOffset","sLength","sOffset","rPadding","sPadding","dst","allocUnsafe","copy","Math","max","o","toString","replace","joseToDer","signatureBytes","rsBytes","shortLength"]
}
