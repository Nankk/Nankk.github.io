{
"version":3,
"file":"module$node_modules$node_forge$lib$cipherModes.js",
"lineCount":30,
"mappings":"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",
"sources":["node_modules/node-forge/lib/cipherModes.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$node_forge$lib$cipherModes\"] = function(global,require,module,exports) {\n/**\n * Supported cipher modes.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\n\nforge.cipher = forge.cipher || {};\n\n// supported cipher modes\nvar modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};\n\n/** Electronic codebook (ECB) (Don't use this; it's not secure) **/\n\nmodes.ecb = function(options) {\n  options = options || {};\n  this.name = 'ECB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n};\n\nmodes.ecb.prototype.start = function(options) {};\n\nmodes.ecb.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  for(var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // write output\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\nmodes.ecb.prototype.decrypt = function(input, output, finish) {\n  // not enough input to decrypt\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  for(var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // decrypt block\n  this.cipher.decrypt(this._inBlock, this._outBlock);\n\n  // write output\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\nmodes.ecb.prototype.pad = function(input, options) {\n  // add PKCS#7 padding to block (each pad byte is the\n  // value of the number of pad bytes)\n  var padding = (input.length() === this.blockSize ?\n    this.blockSize : (this.blockSize - input.length()));\n  input.fillWithByte(padding, padding);\n  return true;\n};\n\nmodes.ecb.prototype.unpad = function(output, options) {\n  // check for error: input data not a multiple of blockSize\n  if(options.overflow > 0) {\n    return false;\n  }\n\n  // ensure padding byte count is valid\n  var len = output.length();\n  var count = output.at(len - 1);\n  if(count > (this.blockSize << 2)) {\n    return false;\n  }\n\n  // trim off padding bytes\n  output.truncate(count);\n  return true;\n};\n\n/** Cipher-block Chaining (CBC) **/\n\nmodes.cbc = function(options) {\n  options = options || {};\n  this.name = 'CBC';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n};\n\nmodes.cbc.prototype.start = function(options) {\n  // Note: legacy support for using IV residue (has security flaws)\n  // if IV is null, reuse block from previous processing\n  if(options.iv === null) {\n    // must have a previous block\n    if(!this._prev) {\n      throw new Error('Invalid IV parameter.');\n    }\n    this._iv = this._prev.slice(0);\n  } else if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  } else {\n    // save IV as \"previous\" block\n    this._iv = transformIV(options.iv, this.blockSize);\n    this._prev = this._iv.slice(0);\n  }\n};\n\nmodes.cbc.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  // CBC XOR's IV (or previous block) with plaintext\n  for(var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = this._prev[i] ^ input.getInt32();\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // write output, save previous block\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n  this._prev = this._outBlock;\n};\n\nmodes.cbc.prototype.decrypt = function(input, output, finish) {\n  // not enough input to decrypt\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  // get next block\n  for(var i = 0; i < this._ints; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // decrypt block\n  this.cipher.decrypt(this._inBlock, this._outBlock);\n\n  // write output, save previous ciphered block\n  // CBC XOR's IV (or previous block) with ciphertext\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._prev[i] ^ this._outBlock[i]);\n  }\n  this._prev = this._inBlock.slice(0);\n};\n\nmodes.cbc.prototype.pad = function(input, options) {\n  // add PKCS#7 padding to block (each pad byte is the\n  // value of the number of pad bytes)\n  var padding = (input.length() === this.blockSize ?\n    this.blockSize : (this.blockSize - input.length()));\n  input.fillWithByte(padding, padding);\n  return true;\n};\n\nmodes.cbc.prototype.unpad = function(output, options) {\n  // check for error: input data not a multiple of blockSize\n  if(options.overflow > 0) {\n    return false;\n  }\n\n  // ensure padding byte count is valid\n  var len = output.length();\n  var count = output.at(len - 1);\n  if(count > (this.blockSize << 2)) {\n    return false;\n  }\n\n  // trim off padding bytes\n  output.truncate(count);\n  return true;\n};\n\n/** Cipher feedback (CFB) **/\n\nmodes.cfb = function(options) {\n  options = options || {};\n  this.name = 'CFB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.start = function(options) {\n  if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // use IV as first input\n  this._iv = transformIV(options.iv, this.blockSize);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if(inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output, write input as output\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = input.getInt32() ^ this._outBlock[i];\n      output.putInt32(this._inBlock[i]);\n    }\n    return;\n  }\n\n  // handle partial block\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n  if(partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  }\n\n  // XOR input with output, write input as partial output\n  this._partialOutput.clear();\n  for(var i = 0; i < this._ints; ++i) {\n    this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];\n    this._partialOutput.putInt32(this._partialBlock[i]);\n  }\n\n  if(partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._partialBlock[i];\n    }\n  }\n\n  // skip any previous partial bytes\n  if(this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if(partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(\n      partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(\n    inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n\nmodes.cfb.prototype.decrypt = function(input, output, finish) {\n  // not enough input to decrypt\n  var inputLength = input.length();\n  if(inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block (CFB always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output, write input as output\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = input.getInt32();\n      output.putInt32(this._inBlock[i] ^ this._outBlock[i]);\n    }\n    return;\n  }\n\n  // handle partial block\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n  if(partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  }\n\n  // XOR input with output, write input as partial output\n  this._partialOutput.clear();\n  for(var i = 0; i < this._ints; ++i) {\n    this._partialBlock[i] = input.getInt32();\n    this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);\n  }\n\n  if(partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._partialBlock[i];\n    }\n  }\n\n  // skip any previous partial bytes\n  if(this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if(partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(\n      partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(\n    inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n\n/** Output feedback (OFB) **/\n\nmodes.ofb = function(options) {\n  options = options || {};\n  this.name = 'OFB';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.start = function(options) {\n  if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // use IV as first input\n  this._iv = transformIV(options.iv, this.blockSize);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if(input.length() === 0) {\n    return true;\n  }\n\n  // encrypt block (OFB always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output and update next input\n    for(var i = 0; i < this._ints; ++i) {\n      output.putInt32(input.getInt32() ^ this._outBlock[i]);\n      this._inBlock[i] = this._outBlock[i];\n    }\n    return;\n  }\n\n  // handle partial block\n  var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n  if(partialBytes > 0) {\n    partialBytes = this.blockSize - partialBytes;\n  }\n\n  // XOR input with output\n  this._partialOutput.clear();\n  for(var i = 0; i < this._ints; ++i) {\n    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n  }\n\n  if(partialBytes > 0) {\n    // block still incomplete, restore input buffer\n    input.read -= this.blockSize;\n  } else {\n    // block complete, update input block\n    for(var i = 0; i < this._ints; ++i) {\n      this._inBlock[i] = this._outBlock[i];\n    }\n  }\n\n  // skip any previous partial bytes\n  if(this._partialBytes > 0) {\n    this._partialOutput.getBytes(this._partialBytes);\n  }\n\n  if(partialBytes > 0 && !finish) {\n    output.putBytes(this._partialOutput.getBytes(\n      partialBytes - this._partialBytes));\n    this._partialBytes = partialBytes;\n    return true;\n  }\n\n  output.putBytes(this._partialOutput.getBytes(\n    inputLength - this._partialBytes));\n  this._partialBytes = 0;\n};\n\nmodes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;\n\n/** Counter (CTR) **/\n\nmodes.ctr = function(options) {\n  options = options || {};\n  this.name = 'CTR';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = null;\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n};\n\nmodes.ctr.prototype.start = function(options) {\n  if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // use IV as first input\n  this._iv = transformIV(options.iv, this.blockSize);\n  this._inBlock = this._iv.slice(0);\n  this._partialBytes = 0;\n};\n\nmodes.ctr.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if(inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block (CTR always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output\n    for(var i = 0; i < this._ints; ++i) {\n      output.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n  } else {\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n    if(partialBytes > 0) {\n      partialBytes = this.blockSize - partialBytes;\n    }\n\n    // XOR input with output\n    this._partialOutput.clear();\n    for(var i = 0; i < this._ints; ++i) {\n      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n\n    if(partialBytes > 0) {\n      // block still incomplete, restore input buffer\n      input.read -= this.blockSize;\n    }\n\n    // skip any previous partial bytes\n    if(this._partialBytes > 0) {\n      this._partialOutput.getBytes(this._partialBytes);\n    }\n\n    if(partialBytes > 0 && !finish) {\n      output.putBytes(this._partialOutput.getBytes(\n        partialBytes - this._partialBytes));\n      this._partialBytes = partialBytes;\n      return true;\n    }\n\n    output.putBytes(this._partialOutput.getBytes(\n      inputLength - this._partialBytes));\n    this._partialBytes = 0;\n  }\n\n  // block complete, increment counter (input block)\n  inc32(this._inBlock);\n};\n\nmodes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;\n\n/** Galois/Counter Mode (GCM) **/\n\nmodes.gcm = function(options) {\n  options = options || {};\n  this.name = 'GCM';\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._ints = this.blockSize / 4;\n  this._inBlock = new Array(this._ints);\n  this._outBlock = new Array(this._ints);\n  this._partialOutput = forge.util.createBuffer();\n  this._partialBytes = 0;\n\n  // R is actually this value concatenated with 120 more zero bits, but\n  // we only XOR against R so the other zeros have no effect -- we just\n  // apply this value to the first integer in a block\n  this._R = 0xE1000000;\n};\n\nmodes.gcm.prototype.start = function(options) {\n  if(!('iv' in options)) {\n    throw new Error('Invalid IV parameter.');\n  }\n  // ensure IV is a byte buffer\n  var iv = forge.util.createBuffer(options.iv);\n\n  // no ciphered data processed yet\n  this._cipherLength = 0;\n\n  // default additional data is none\n  var additionalData;\n  if('additionalData' in options) {\n    additionalData = forge.util.createBuffer(options.additionalData);\n  } else {\n    additionalData = forge.util.createBuffer();\n  }\n\n  // default tag length is 128 bits\n  if('tagLength' in options) {\n    this._tagLength = options.tagLength;\n  } else {\n    this._tagLength = 128;\n  }\n\n  // if tag is given, ensure tag matches tag length\n  this._tag = null;\n  if(options.decrypt) {\n    // save tag to check later\n    this._tag = forge.util.createBuffer(options.tag).getBytes();\n    if(this._tag.length !== (this._tagLength / 8)) {\n      throw new Error('Authentication tag does not match tag length.');\n    }\n  }\n\n  // create tmp storage for hash calculation\n  this._hashBlock = new Array(this._ints);\n\n  // no tag generated yet\n  this.tag = null;\n\n  // generate hash subkey\n  // (apply block cipher to \"zero\" block)\n  this._hashSubkey = new Array(this._ints);\n  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);\n\n  // generate table M\n  // use 4-bit tables (32 component decomposition of a 16 byte value)\n  // 8-bit tables take more space and are known to have security\n  // vulnerabilities (in native implementations)\n  this.componentBits = 4;\n  this._m = this.generateHashTable(this._hashSubkey, this.componentBits);\n\n  // Note: support IV length different from 96 bits? (only supporting\n  // 96 bits is recommended by NIST SP-800-38D)\n  // generate J_0\n  var ivLength = iv.length();\n  if(ivLength === 12) {\n    // 96-bit IV\n    this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];\n  } else {\n    // IV is NOT 96-bits\n    this._j0 = [0, 0, 0, 0];\n    while(iv.length() > 0) {\n      this._j0 = this.ghash(\n        this._hashSubkey, this._j0,\n        [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);\n    }\n    this._j0 = this.ghash(\n      this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));\n  }\n\n  // generate ICB (initial counter block)\n  this._inBlock = this._j0.slice(0);\n  inc32(this._inBlock);\n  this._partialBytes = 0;\n\n  // consume authentication data\n  additionalData = forge.util.createBuffer(additionalData);\n  // save additional data length as a BE 64-bit number\n  this._aDataLength = from64To32(additionalData.length() * 8);\n  // pad additional data to 128 bit (16 byte) block size\n  var overflow = additionalData.length() % this.blockSize;\n  if(overflow) {\n    additionalData.fillWithByte(0, this.blockSize - overflow);\n  }\n  this._s = [0, 0, 0, 0];\n  while(additionalData.length() > 0) {\n    this._s = this.ghash(this._hashSubkey, this._s, [\n      additionalData.getInt32(),\n      additionalData.getInt32(),\n      additionalData.getInt32(),\n      additionalData.getInt32()\n    ]);\n  }\n};\n\nmodes.gcm.prototype.encrypt = function(input, output, finish) {\n  // not enough input to encrypt\n  var inputLength = input.length();\n  if(inputLength === 0) {\n    return true;\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // handle full block\n  if(this._partialBytes === 0 && inputLength >= this.blockSize) {\n    // XOR input with output\n    for(var i = 0; i < this._ints; ++i) {\n      output.putInt32(this._outBlock[i] ^= input.getInt32());\n    }\n    this._cipherLength += this.blockSize;\n  } else {\n    // handle partial block\n    var partialBytes = (this.blockSize - inputLength) % this.blockSize;\n    if(partialBytes > 0) {\n      partialBytes = this.blockSize - partialBytes;\n    }\n\n    // XOR input with output\n    this._partialOutput.clear();\n    for(var i = 0; i < this._ints; ++i) {\n      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);\n    }\n\n    if(partialBytes <= 0 || finish) {\n      // handle overflow prior to hashing\n      if(finish) {\n        // get block overflow\n        var overflow = inputLength % this.blockSize;\n        this._cipherLength += overflow;\n        // truncate for hash function\n        this._partialOutput.truncate(this.blockSize - overflow);\n      } else {\n        this._cipherLength += this.blockSize;\n      }\n\n      // get output block for hashing\n      for(var i = 0; i < this._ints; ++i) {\n        this._outBlock[i] = this._partialOutput.getInt32();\n      }\n      this._partialOutput.read -= this.blockSize;\n    }\n\n    // skip any previous partial bytes\n    if(this._partialBytes > 0) {\n      this._partialOutput.getBytes(this._partialBytes);\n    }\n\n    if(partialBytes > 0 && !finish) {\n      // block still incomplete, restore input buffer, get partial output,\n      // and return early\n      input.read -= this.blockSize;\n      output.putBytes(this._partialOutput.getBytes(\n        partialBytes - this._partialBytes));\n      this._partialBytes = partialBytes;\n      return true;\n    }\n\n    output.putBytes(this._partialOutput.getBytes(\n      inputLength - this._partialBytes));\n    this._partialBytes = 0;\n  }\n\n  // update hash block S\n  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);\n\n  // increment counter (input block)\n  inc32(this._inBlock);\n};\n\nmodes.gcm.prototype.decrypt = function(input, output, finish) {\n  // not enough input to decrypt\n  var inputLength = input.length();\n  if(inputLength < this.blockSize && !(finish && inputLength > 0)) {\n    return true;\n  }\n\n  // encrypt block (GCM always uses encryption mode)\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // increment counter (input block)\n  inc32(this._inBlock);\n\n  // update hash block S\n  this._hashBlock[0] = input.getInt32();\n  this._hashBlock[1] = input.getInt32();\n  this._hashBlock[2] = input.getInt32();\n  this._hashBlock[3] = input.getInt32();\n  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);\n\n  // XOR hash input with output\n  for(var i = 0; i < this._ints; ++i) {\n    output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);\n  }\n\n  // increment cipher data length\n  if(inputLength < this.blockSize) {\n    this._cipherLength += inputLength % this.blockSize;\n  } else {\n    this._cipherLength += this.blockSize;\n  }\n};\n\nmodes.gcm.prototype.afterFinish = function(output, options) {\n  var rval = true;\n\n  // handle overflow\n  if(options.decrypt && options.overflow) {\n    output.truncate(this.blockSize - options.overflow);\n  }\n\n  // handle authentication tag\n  this.tag = forge.util.createBuffer();\n\n  // concatenate additional data length with cipher length\n  var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));\n\n  // include lengths in hash\n  this._s = this.ghash(this._hashSubkey, this._s, lengths);\n\n  // do GCTR(J_0, S)\n  var tag = [];\n  this.cipher.encrypt(this._j0, tag);\n  for(var i = 0; i < this._ints; ++i) {\n    this.tag.putInt32(this._s[i] ^ tag[i]);\n  }\n\n  // trim tag to length\n  this.tag.truncate(this.tag.length() % (this._tagLength / 8));\n\n  // check authentication tag\n  if(options.decrypt && this.tag.bytes() !== this._tag) {\n    rval = false;\n  }\n\n  return rval;\n};\n\n/**\n * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois\n * field multiplication. The field, GF(2^128), is defined by the polynomial:\n *\n * x^128 + x^7 + x^2 + x + 1\n *\n * Which is represented in little-endian binary form as: 11100001 (0xe1). When\n * the value of a coefficient is 1, a bit is set. The value R, is the\n * concatenation of this value and 120 zero bits, yielding a 128-bit value\n * which matches the block size.\n *\n * This function will multiply two elements (vectors of bytes), X and Y, in\n * the field GF(2^128). The result is initialized to zero. For each bit of\n * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)\n * by the current value of Y. For each bit, the value of Y will be raised by\n * a power of x (multiplied by the polynomial x). This can be achieved by\n * shifting Y once to the right. If the current value of Y, prior to being\n * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.\n * Otherwise, we must divide by R after shifting to find the remainder.\n *\n * @param x the first block to multiply by the second.\n * @param y the second block to multiply by the first.\n *\n * @return the block result of the multiplication.\n */\nmodes.gcm.prototype.multiply = function(x, y) {\n  var z_i = [0, 0, 0, 0];\n  var v_i = y.slice(0);\n\n  // calculate Z_128 (block has 128 bits)\n  for(var i = 0; i < 128; ++i) {\n    // if x_i is 0, Z_{i+1} = Z_i (unchanged)\n    // else Z_{i+1} = Z_i ^ V_i\n    // get x_i by finding 32-bit int position, then left shift 1 by remainder\n    var x_i = x[(i / 32) | 0] & (1 << (31 - i % 32));\n    if(x_i) {\n      z_i[0] ^= v_i[0];\n      z_i[1] ^= v_i[1];\n      z_i[2] ^= v_i[2];\n      z_i[3] ^= v_i[3];\n    }\n\n    // if LSB(V_i) is 1, V_i = V_i >> 1\n    // else V_i = (V_i >> 1) ^ R\n    this.pow(v_i, v_i);\n  }\n\n  return z_i;\n};\n\nmodes.gcm.prototype.pow = function(x, out) {\n  // if LSB(x) is 1, x = x >>> 1\n  // else x = (x >>> 1) ^ R\n  var lsb = x[3] & 1;\n\n  // always do x >>> 1:\n  // starting with the rightmost integer, shift each integer to the right\n  // one bit, pulling in the bit from the integer to the left as its top\n  // most bit (do this for the last 3 integers)\n  for(var i = 3; i > 0; --i) {\n    out[i] = (x[i] >>> 1) | ((x[i - 1] & 1) << 31);\n  }\n  // shift the first integer normally\n  out[0] = x[0] >>> 1;\n\n  // if lsb was not set, then polynomial had a degree of 127 and doesn't\n  // need to divided; otherwise, XOR with R to find the remainder; we only\n  // need to XOR the first integer since R technically ends w/120 zero bits\n  if(lsb) {\n    out[0] ^= this._R;\n  }\n};\n\nmodes.gcm.prototype.tableMultiply = function(x) {\n  // assumes 4-bit tables are used\n  var z = [0, 0, 0, 0];\n  for(var i = 0; i < 32; ++i) {\n    var idx = (i / 8) | 0;\n    var x_i = (x[idx] >>> ((7 - (i % 8)) * 4)) & 0xF;\n    var ah = this._m[i][x_i];\n    z[0] ^= ah[0];\n    z[1] ^= ah[1];\n    z[2] ^= ah[2];\n    z[3] ^= ah[3];\n  }\n  return z;\n};\n\n/**\n * A continuing version of the GHASH algorithm that operates on a single\n * block. The hash block, last hash value (Ym) and the new block to hash\n * are given.\n *\n * @param h the hash block.\n * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.\n * @param x the block to hash.\n *\n * @return the hashed value (Ym).\n */\nmodes.gcm.prototype.ghash = function(h, y, x) {\n  y[0] ^= x[0];\n  y[1] ^= x[1];\n  y[2] ^= x[2];\n  y[3] ^= x[3];\n  return this.tableMultiply(y);\n  //return this.multiply(y, h);\n};\n\n/**\n * Precomputes a table for multiplying against the hash subkey. This\n * mechanism provides a substantial speed increase over multiplication\n * performed without a table. The table-based multiplication this table is\n * for solves X * H by multiplying each component of X by H and then\n * composing the results together using XOR.\n *\n * This function can be used to generate tables with different bit sizes\n * for the components, however, this implementation assumes there are\n * 32 components of X (which is a 16 byte vector), therefore each component\n * takes 4-bits (so the table is constructed with bits=4).\n *\n * @param h the hash subkey.\n * @param bits the bit size for a component.\n */\nmodes.gcm.prototype.generateHashTable = function(h, bits) {\n  // TODO: There are further optimizations that would use only the\n  // first table M_0 (or some variant) along with a remainder table;\n  // this can be explored in the future\n  var multiplier = 8 / bits;\n  var perInt = 4 * multiplier;\n  var size = 16 * multiplier;\n  var m = new Array(size);\n  for(var i = 0; i < size; ++i) {\n    var tmp = [0, 0, 0, 0];\n    var idx = (i / perInt) | 0;\n    var shft = ((perInt - 1 - (i % perInt)) * bits);\n    tmp[idx] = (1 << (bits - 1)) << shft;\n    m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);\n  }\n  return m;\n};\n\n/**\n * Generates a table for multiplying against the hash subkey for one\n * particular component (out of all possible component values).\n *\n * @param mid the pre-multiplied value for the middle key of the table.\n * @param bits the bit size for a component.\n */\nmodes.gcm.prototype.generateSubHashTable = function(mid, bits) {\n  // compute the table quickly by minimizing the number of\n  // POW operations -- they only need to be performed for powers of 2,\n  // all other entries can be composed from those powers using XOR\n  var size = 1 << bits;\n  var half = size >>> 1;\n  var m = new Array(size);\n  m[half] = mid.slice(0);\n  var i = half >>> 1;\n  while(i > 0) {\n    // raise m0[2 * i] and store in m0[i]\n    this.pow(m[2 * i], m[i] = []);\n    i >>= 1;\n  }\n  i = 2;\n  while(i < half) {\n    for(var j = 1; j < i; ++j) {\n      var m_i = m[i];\n      var m_j = m[j];\n      m[i + j] = [\n        m_i[0] ^ m_j[0],\n        m_i[1] ^ m_j[1],\n        m_i[2] ^ m_j[2],\n        m_i[3] ^ m_j[3]\n      ];\n    }\n    i *= 2;\n  }\n  m[0] = [0, 0, 0, 0];\n  /* Note: We could avoid storing these by doing composition during multiply\n  calculate top half using composition by speed is preferred. */\n  for(i = half + 1; i < size; ++i) {\n    var c = m[i ^ half];\n    m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];\n  }\n  return m;\n};\n\n/** Utility functions */\n\nfunction transformIV(iv, blockSize) {\n  if(typeof iv === 'string') {\n    // convert iv string into byte buffer\n    iv = forge.util.createBuffer(iv);\n  }\n\n  if(forge.util.isArray(iv) && iv.length > 4) {\n    // convert iv byte array into byte buffer\n    var tmp = iv;\n    iv = forge.util.createBuffer();\n    for(var i = 0; i < tmp.length; ++i) {\n      iv.putByte(tmp[i]);\n    }\n  }\n\n  if(iv.length() < blockSize) {\n    throw new Error(\n      'Invalid IV length; got ' + iv.length() +\n      ' bytes and expected ' + blockSize + ' bytes.');\n  }\n\n  if(!forge.util.isArray(iv)) {\n    // convert iv byte buffer into 32-bit integer array\n    var ints = [];\n    var blocks = blockSize / 4;\n    for(var i = 0; i < blocks; ++i) {\n      ints.push(iv.getInt32());\n    }\n    iv = ints;\n  }\n\n  return iv;\n}\n\nfunction inc32(block) {\n  // increment last 32 bits of block only\n  block[block.length - 1] = (block[block.length - 1] + 1) & 0xFFFFFFFF;\n}\n\nfunction from64To32(num) {\n  // convert 64-bit number to two BE Int32s\n  return [(num / 0x100000000) | 0, num & 0xFFFFFFFF];\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","transformIV","iv","blockSize","forge","util","createBuffer","isArray","length","tmp","i","putByte","Error","ints","blocks","push","getInt32","inc32","block","from64To32","num","cipher","modes","ecb","modes.ecb","options","name","_ints","_inBlock","Array","_outBlock","prototype","start","modes.ecb.prototype.start","encrypt","modes.ecb.prototype.encrypt","input","output","finish","putInt32","decrypt","modes.ecb.prototype.decrypt","pad","modes.ecb.prototype.pad","padding","fillWithByte","unpad","modes.ecb.prototype.unpad","overflow","len","count","at","truncate","cbc","modes.cbc","modes.cbc.prototype.start","_prev","_iv","slice","modes.cbc.prototype.encrypt","modes.cbc.prototype.decrypt","modes.cbc.prototype.pad","modes.cbc.prototype.unpad","cfb","modes.cfb","_partialBlock","_partialOutput","_partialBytes","modes.cfb.prototype.start","modes.cfb.prototype.encrypt","inputLength","partialBytes","clear","read","getBytes","putBytes","modes.cfb.prototype.decrypt","ofb","modes.ofb","modes.ofb.prototype.start","modes.ofb.prototype.encrypt","ctr","modes.ctr","modes.ctr.prototype.start","modes.ctr.prototype.encrypt","gcm","modes.gcm","_R","modes.gcm.prototype.start","_cipherLength","additionalData","_tagLength","tagLength","_tag","tag","_hashBlock","_hashSubkey","componentBits","_m","generateHashTable","ivLength","_j0","ghash","concat","_aDataLength","_s","modes.gcm.prototype.encrypt","modes.gcm.prototype.decrypt","afterFinish","modes.gcm.prototype.afterFinish","rval","lengths","bytes","multiply","modes.gcm.prototype.multiply","x","y","z_i","v_i","pow","modes.gcm.prototype.pow","out","lsb","tableMultiply","modes.gcm.prototype.tableMultiply","z","ah","modes.gcm.prototype.ghash","h","modes.gcm.prototype.generateHashTable","bits","multiplier","perInt","size","m","generateSubHashTable","modes.gcm.prototype.generateSubHashTable","mid","half","j","m_i","m_j","c"]
}
