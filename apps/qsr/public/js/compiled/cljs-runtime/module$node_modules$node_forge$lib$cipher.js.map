{
"version":3,
"file":"module$node_modules$node_forge$lib$cipher.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/node-forge/lib/cipher.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$node_forge$lib$cipher\"] = function(global,require,module,exports) {\n/**\n * Cipher base API.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\n\nmodule.exports = forge.cipher = forge.cipher || {};\n\n// registered algorithms\nforge.cipher.algorithms = forge.cipher.algorithms || {};\n\n/**\n * Creates a cipher object that can be used to encrypt data using the given\n * algorithm and key. The algorithm may be provided as a string value for a\n * previously registered algorithm or it may be given as a cipher algorithm\n * API object.\n *\n * @param algorithm the algorithm to use, either a string or an algorithm API\n *          object.\n * @param key the key to use, as a binary-encoded string of bytes or a\n *          byte buffer.\n *\n * @return the cipher.\n */\nforge.cipher.createCipher = function(algorithm, key) {\n  var api = algorithm;\n  if(typeof api === 'string') {\n    api = forge.cipher.getAlgorithm(api);\n    if(api) {\n      api = api();\n    }\n  }\n  if(!api) {\n    throw new Error('Unsupported algorithm: ' + algorithm);\n  }\n\n  // assume block cipher\n  return new forge.cipher.BlockCipher({\n    algorithm: api,\n    key: key,\n    decrypt: false\n  });\n};\n\n/**\n * Creates a decipher object that can be used to decrypt data using the given\n * algorithm and key. The algorithm may be provided as a string value for a\n * previously registered algorithm or it may be given as a cipher algorithm\n * API object.\n *\n * @param algorithm the algorithm to use, either a string or an algorithm API\n *          object.\n * @param key the key to use, as a binary-encoded string of bytes or a\n *          byte buffer.\n *\n * @return the cipher.\n */\nforge.cipher.createDecipher = function(algorithm, key) {\n  var api = algorithm;\n  if(typeof api === 'string') {\n    api = forge.cipher.getAlgorithm(api);\n    if(api) {\n      api = api();\n    }\n  }\n  if(!api) {\n    throw new Error('Unsupported algorithm: ' + algorithm);\n  }\n\n  // assume block cipher\n  return new forge.cipher.BlockCipher({\n    algorithm: api,\n    key: key,\n    decrypt: true\n  });\n};\n\n/**\n * Registers an algorithm by name. If the name was already registered, the\n * algorithm API object will be overwritten.\n *\n * @param name the name of the algorithm.\n * @param algorithm the algorithm API object.\n */\nforge.cipher.registerAlgorithm = function(name, algorithm) {\n  name = name.toUpperCase();\n  forge.cipher.algorithms[name] = algorithm;\n};\n\n/**\n * Gets a registered algorithm by name.\n *\n * @param name the name of the algorithm.\n *\n * @return the algorithm, if found, null if not.\n */\nforge.cipher.getAlgorithm = function(name) {\n  name = name.toUpperCase();\n  if(name in forge.cipher.algorithms) {\n    return forge.cipher.algorithms[name];\n  }\n  return null;\n};\n\nvar BlockCipher = forge.cipher.BlockCipher = function(options) {\n  this.algorithm = options.algorithm;\n  this.mode = this.algorithm.mode;\n  this.blockSize = this.mode.blockSize;\n  this._finish = false;\n  this._input = null;\n  this.output = null;\n  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;\n  this._decrypt = options.decrypt;\n  this.algorithm.initialize(options);\n};\n\n/**\n * Starts or restarts the encryption or decryption process, whichever\n * was previously configured.\n *\n * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array\n * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in\n * bytes, then it must be Nb (16) bytes in length. If the IV is given in as\n * 32-bit integers, then it must be 4 integers long.\n *\n * Note: an IV is not required or used in ECB mode.\n *\n * For GCM-mode, the IV must be given as a binary-encoded string of bytes or\n * a byte buffer. The number of bytes should be 12 (96 bits) as recommended\n * by NIST SP-800-38D but another length may be given.\n *\n * @param options the options to use:\n *          iv the initialization vector to use as a binary-encoded string of\n *            bytes, null to reuse the last ciphered block from a previous\n *            update() (this \"residue\" method is for legacy support only).\n *          additionalData additional authentication data as a binary-encoded\n *            string of bytes, for 'GCM' mode, (default: none).\n *          tagLength desired length of authentication tag, in bits, for\n *            'GCM' mode (0-128, default: 128).\n *          tag the authentication tag to check if decrypting, as a\n *             binary-encoded string of bytes.\n *          output the output the buffer to write to, null to create one.\n */\nBlockCipher.prototype.start = function(options) {\n  options = options || {};\n  var opts = {};\n  for(var key in options) {\n    opts[key] = options[key];\n  }\n  opts.decrypt = this._decrypt;\n  this._finish = false;\n  this._input = forge.util.createBuffer();\n  this.output = options.output || forge.util.createBuffer();\n  this.mode.start(opts);\n};\n\n/**\n * Updates the next block according to the cipher mode.\n *\n * @param input the buffer to read from.\n */\nBlockCipher.prototype.update = function(input) {\n  if(input) {\n    // input given, so empty it into the input buffer\n    this._input.putBuffer(input);\n  }\n\n  // do cipher operation until it needs more input and not finished\n  while(!this._op.call(this.mode, this._input, this.output, this._finish) &&\n    !this._finish) {}\n\n  // free consumed memory from input buffer\n  this._input.compact();\n};\n\n/**\n * Finishes encrypting or decrypting.\n *\n * @param pad a padding function to use in CBC mode, null for default,\n *          signature(blockSize, buffer, decrypt).\n *\n * @return true if successful, false on error.\n */\nBlockCipher.prototype.finish = function(pad) {\n  // backwards-compatibility w/deprecated padding API\n  // Note: will overwrite padding functions even after another start() call\n  if(pad && (this.mode.name === 'ECB' || this.mode.name === 'CBC')) {\n    this.mode.pad = function(input) {\n      return pad(this.blockSize, input, false);\n    };\n    this.mode.unpad = function(output) {\n      return pad(this.blockSize, output, true);\n    };\n  }\n\n  // build options for padding and afterFinish functions\n  var options = {};\n  options.decrypt = this._decrypt;\n\n  // get # of bytes that won't fill a block\n  options.overflow = this._input.length() % this.blockSize;\n\n  if(!this._decrypt && this.mode.pad) {\n    if(!this.mode.pad(this._input, options)) {\n      return false;\n    }\n  }\n\n  // do final update\n  this._finish = true;\n  this.update();\n\n  if(this._decrypt && this.mode.unpad) {\n    if(!this.mode.unpad(this.output, options)) {\n      return false;\n    }\n  }\n\n  if(this.mode.afterFinish) {\n    if(!this.mode.afterFinish(this.output, options)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","forge","cipher","algorithms","createCipher","forge.cipher.createCipher","algorithm","key","api","getAlgorithm","Error","BlockCipher","decrypt","createDecipher","forge.cipher.createDecipher","registerAlgorithm","forge.cipher.registerAlgorithm","name","toUpperCase","forge.cipher.getAlgorithm","forge.cipher.BlockCipher","options","mode","blockSize","_finish","output","_input","_op","encrypt","_decrypt","initialize","prototype","start","BlockCipher.prototype.start","opts","util","createBuffer","update","BlockCipher.prototype.update","input","putBuffer","call","compact","finish","BlockCipher.prototype.finish","pad","this.mode.pad","unpad","this.mode.unpad","overflow","length","afterFinish"]
}
