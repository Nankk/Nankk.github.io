{
"version":3,
"file":"module$node_modules$node_forge$lib$pss.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/node-forge/lib/pss.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$node_forge$lib$pss\"] = function(global,require,module,exports) {\n/**\n * Javascript implementation of PKCS#1 PSS signature padding.\n *\n * @author Stefan Siegl\n *\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n */\nvar forge = require('./forge');\nrequire('./random');\nrequire('./util');\n\n// shortcut for PSS API\nvar pss = module.exports = forge.pss = forge.pss || {};\n\n/**\n * Creates a PSS signature scheme object.\n *\n * There are several ways to provide a salt for encoding:\n *\n * 1. Specify the saltLength only and the built-in PRNG will generate it.\n * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that\n *   will be used.\n * 3. Specify the salt itself as a forge.util.ByteBuffer.\n *\n * @param options the options to use:\n *          md the message digest object to use, a forge md instance.\n *          mgf the mask generation function to use, a forge mgf instance.\n *          [saltLength] the length of the salt in octets.\n *          [prng] the pseudo-random number generator to use to produce a salt.\n *          [salt] the salt to use when encoding.\n *\n * @return a signature scheme object.\n */\npss.create = function(options) {\n  // backwards compatibility w/legacy args: hash, mgf, sLen\n  if(arguments.length === 3) {\n    options = {\n      md: arguments[0],\n      mgf: arguments[1],\n      saltLength: arguments[2]\n    };\n  }\n\n  var hash = options.md;\n  var mgf = options.mgf;\n  var hLen = hash.digestLength;\n\n  var salt_ = options.salt || null;\n  if(typeof salt_ === 'string') {\n    // assume binary-encoded string\n    salt_ = forge.util.createBuffer(salt_);\n  }\n\n  var sLen;\n  if('saltLength' in options) {\n    sLen = options.saltLength;\n  } else if(salt_ !== null) {\n    sLen = salt_.length();\n  } else {\n    throw new Error('Salt length not specified or specific salt not given.');\n  }\n\n  if(salt_ !== null && salt_.length() !== sLen) {\n    throw new Error('Given salt length does not match length of given salt.');\n  }\n\n  var prng = options.prng || forge.random;\n\n  var pssobj = {};\n\n  /**\n   * Encodes a PSS signature.\n   *\n   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.\n   *\n   * @param md the message digest object with the hash to sign.\n   * @param modsBits the length of the RSA modulus in bits.\n   *\n   * @return the encoded message as a binary-encoded string of length\n   *           ceil((modBits - 1) / 8).\n   */\n  pssobj.encode = function(md, modBits) {\n    var i;\n    var emBits = modBits - 1;\n    var emLen = Math.ceil(emBits / 8);\n\n    /* 2. Let mHash = Hash(M), an octet string of length hLen. */\n    var mHash = md.digest().getBytes();\n\n    /* 3. If emLen < hLen + sLen + 2, output \"encoding error\" and stop. */\n    if(emLen < hLen + sLen + 2) {\n      throw new Error('Message is too long to encrypt.');\n    }\n\n    /* 4. Generate a random octet string salt of length sLen; if sLen = 0,\n     *    then salt is the empty string. */\n    var salt;\n    if(salt_ === null) {\n      salt = prng.getBytesSync(sLen);\n    } else {\n      salt = salt_.bytes();\n    }\n\n    /* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */\n    var m_ = new forge.util.ByteBuffer();\n    m_.fillWithByte(0, 8);\n    m_.putBytes(mHash);\n    m_.putBytes(salt);\n\n    /* 6. Let H = Hash(M'), an octet string of length hLen. */\n    hash.start();\n    hash.update(m_.getBytes());\n    var h = hash.digest().getBytes();\n\n    /* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2\n     *    zero octets.  The length of PS may be 0. */\n    var ps = new forge.util.ByteBuffer();\n    ps.fillWithByte(0, emLen - sLen - hLen - 2);\n\n    /* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length\n     *    emLen - hLen - 1. */\n    ps.putByte(0x01);\n    ps.putBytes(salt);\n    var db = ps.getBytes();\n\n    /* 9. Let dbMask = MGF(H, emLen - hLen - 1). */\n    var maskLen = emLen - hLen - 1;\n    var dbMask = mgf.generate(h, maskLen);\n\n    /* 10. Let maskedDB = DB \\xor dbMask. */\n    var maskedDB = '';\n    for(i = 0; i < maskLen; i++) {\n      maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));\n    }\n\n    /* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in\n     *     maskedDB to zero. */\n    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;\n    maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) +\n      maskedDB.substr(1);\n\n    /* 12. Let EM = maskedDB || H || 0xbc.\n     * 13. Output EM. */\n    return maskedDB + h + String.fromCharCode(0xbc);\n  };\n\n  /**\n   * Verifies a PSS signature.\n   *\n   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.\n   *\n   * @param mHash the message digest hash, as a binary-encoded string, to\n   *         compare against the signature.\n   * @param em the encoded message, as a binary-encoded string\n   *          (RSA decryption result).\n   * @param modsBits the length of the RSA modulus in bits.\n   *\n   * @return true if the signature was verified, false if not.\n   */\n  pssobj.verify = function(mHash, em, modBits) {\n    var i;\n    var emBits = modBits - 1;\n    var emLen = Math.ceil(emBits / 8);\n\n    /* c. Convert the message representative m to an encoded message EM\n     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits\n     *    is the length in bits of the RSA modulus n */\n    em = em.substr(-emLen);\n\n    /* 3. If emLen < hLen + sLen + 2, output \"inconsistent\" and stop. */\n    if(emLen < hLen + sLen + 2) {\n      throw new Error('Inconsistent parameters to PSS signature verification.');\n    }\n\n    /* 4. If the rightmost octet of EM does not have hexadecimal value\n     *    0xbc, output \"inconsistent\" and stop. */\n    if(em.charCodeAt(emLen - 1) !== 0xbc) {\n      throw new Error('Encoded message does not end in 0xBC.');\n    }\n\n    /* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and\n     *    let H be the next hLen octets. */\n    var maskLen = emLen - hLen - 1;\n    var maskedDB = em.substr(0, maskLen);\n    var h = em.substr(maskLen, hLen);\n\n    /* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in\n     *    maskedDB are not all equal to zero, output \"inconsistent\" and stop. */\n    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;\n    if((maskedDB.charCodeAt(0) & mask) !== 0) {\n      throw new Error('Bits beyond keysize not zero as expected.');\n    }\n\n    /* 7. Let dbMask = MGF(H, emLen - hLen - 1). */\n    var dbMask = mgf.generate(h, maskLen);\n\n    /* 8. Let DB = maskedDB \\xor dbMask. */\n    var db = '';\n    for(i = 0; i < maskLen; i++) {\n      db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));\n    }\n\n    /* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet\n     * in DB to zero. */\n    db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);\n\n    /* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero\n     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost\n     * position is \"position 1\") does not have hexadecimal value 0x01,\n     * output \"inconsistent\" and stop. */\n    var checkLen = emLen - hLen - sLen - 2;\n    for(i = 0; i < checkLen; i++) {\n      if(db.charCodeAt(i) !== 0x00) {\n        throw new Error('Leftmost octets not zero as expected');\n      }\n    }\n\n    if(db.charCodeAt(checkLen) !== 0x01) {\n      throw new Error('Inconsistent PSS signature, 0x01 marker not found');\n    }\n\n    /* 11. Let salt be the last sLen octets of DB. */\n    var salt = db.substr(-sLen);\n\n    /* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */\n    var m_ = new forge.util.ByteBuffer();\n    m_.fillWithByte(0, 8);\n    m_.putBytes(mHash);\n    m_.putBytes(salt);\n\n    /* 13. Let H' = Hash(M'), an octet string of length hLen. */\n    hash.start();\n    hash.update(m_.getBytes());\n    var h_ = hash.digest().getBytes();\n\n    /* 14. If H = H', output \"consistent.\" Otherwise, output \"inconsistent.\" */\n    return h === h_;\n  };\n\n  return pssobj;\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","forge","create","pss","pss.create","options","arguments","length","md","mgf","saltLength","hash","hLen","digestLength","salt_","salt","util","createBuffer","sLen","Error","prng","random","pssobj","pssobj.encode","modBits","emBits","emLen","Math","ceil","mHash","digest","getBytes","getBytesSync","bytes","m_","ByteBuffer","fillWithByte","putBytes","start","update","h","ps","putByte","db","maskLen","dbMask","generate","maskedDB","i","String","fromCharCode","charCodeAt","mask","substr","pssobj.verify","em","checkLen","h_"]
}
