{
"version":3,
"file":"module$node_modules$node_forge$lib$prng.js",
"lineCount":10,
"mappings":"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",
"sources":["node_modules/node-forge/lib/prng.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$node_forge$lib$prng\"] = function(global,require,module,exports) {\nvar process = require('process');\n/**\n * A javascript implementation of a cryptographically-secure\n * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed\n * here though the use of SHA-256 is not enforced; when generating an\n * a PRNG context, the hashing algorithm and block cipher used for\n * the generator are specified via a plugin.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\n\nvar _crypto = null;\nif(forge.util.isNodejs && !forge.options.usePureJavaScript &&\n  !process.versions['node-webkit']) {\n  _crypto = require('crypto');\n}\n\n/* PRNG API */\nvar prng = module.exports = forge.prng = forge.prng || {};\n\n/**\n * Creates a new PRNG context.\n *\n * A PRNG plugin must be passed in that will provide:\n *\n * 1. A function that initializes the key and seed of a PRNG context. It\n *   will be given a 16 byte key and a 16 byte seed. Any key expansion\n *   or transformation of the seed from a byte string into an array of\n *   integers (or similar) should be performed.\n * 2. The cryptographic function used by the generator. It takes a key and\n *   a seed.\n * 3. A seed increment function. It takes the seed and returns seed + 1.\n * 4. An api to create a message digest.\n *\n * For an example, see random.js.\n *\n * @param plugin the PRNG plugin to use.\n */\nprng.create = function(plugin) {\n  var ctx = {\n    plugin: plugin,\n    key: null,\n    seed: null,\n    time: null,\n    // number of reseeds so far\n    reseeds: 0,\n    // amount of data generated so far\n    generated: 0,\n    // no initial key bytes\n    keyBytes: ''\n  };\n\n  // create 32 entropy pools (each is a message digest)\n  var md = plugin.md;\n  var pools = new Array(32);\n  for(var i = 0; i < 32; ++i) {\n    pools[i] = md.create();\n  }\n  ctx.pools = pools;\n\n  // entropy pools are written to cyclically, starting at index 0\n  ctx.pool = 0;\n\n  /**\n   * Generates random bytes. The bytes may be generated synchronously or\n   * asynchronously. Web workers must use the asynchronous interface or\n   * else the behavior is undefined.\n   *\n   * @param count the number of random bytes to generate.\n   * @param [callback(err, bytes)] called once the operation completes.\n   *\n   * @return count random bytes as a string.\n   */\n  ctx.generate = function(count, callback) {\n    // do synchronously\n    if(!callback) {\n      return ctx.generateSync(count);\n    }\n\n    // simple generator using counter-based CBC\n    var cipher = ctx.plugin.cipher;\n    var increment = ctx.plugin.increment;\n    var formatKey = ctx.plugin.formatKey;\n    var formatSeed = ctx.plugin.formatSeed;\n    var b = forge.util.createBuffer();\n\n    // paranoid deviation from Fortuna:\n    // reset key for every request to protect previously\n    // generated random bytes should the key be discovered;\n    // there is no 100ms based reseeding because of this\n    // forced reseed for every `generate` call\n    ctx.key = null;\n\n    generate();\n\n    function generate(err) {\n      if(err) {\n        return callback(err);\n      }\n\n      // sufficient bytes generated\n      if(b.length() >= count) {\n        return callback(null, b.getBytes(count));\n      }\n\n      // if amount of data generated is greater than 1 MiB, trigger reseed\n      if(ctx.generated > 0xfffff) {\n        ctx.key = null;\n      }\n\n      if(ctx.key === null) {\n        // prevent stack overflow\n        return forge.util.nextTick(function() {\n          _reseed(generate);\n        });\n      }\n\n      // generate the random bytes\n      var bytes = cipher(ctx.key, ctx.seed);\n      ctx.generated += bytes.length;\n      b.putBytes(bytes);\n\n      // generate bytes for a new key and seed\n      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n\n      forge.util.setImmediate(generate);\n    }\n  };\n\n  /**\n   * Generates random bytes synchronously.\n   *\n   * @param count the number of random bytes to generate.\n   *\n   * @return count random bytes as a string.\n   */\n  ctx.generateSync = function(count) {\n    // simple generator using counter-based CBC\n    var cipher = ctx.plugin.cipher;\n    var increment = ctx.plugin.increment;\n    var formatKey = ctx.plugin.formatKey;\n    var formatSeed = ctx.plugin.formatSeed;\n\n    // paranoid deviation from Fortuna:\n    // reset key for every request to protect previously\n    // generated random bytes should the key be discovered;\n    // there is no 100ms based reseeding because of this\n    // forced reseed for every `generateSync` call\n    ctx.key = null;\n\n    var b = forge.util.createBuffer();\n    while(b.length() < count) {\n      // if amount of data generated is greater than 1 MiB, trigger reseed\n      if(ctx.generated > 0xfffff) {\n        ctx.key = null;\n      }\n\n      if(ctx.key === null) {\n        _reseedSync();\n      }\n\n      // generate the random bytes\n      var bytes = cipher(ctx.key, ctx.seed);\n      ctx.generated += bytes.length;\n      b.putBytes(bytes);\n\n      // generate bytes for a new key and seed\n      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));\n      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));\n    }\n\n    return b.getBytes(count);\n  };\n\n  /**\n   * Private function that asynchronously reseeds a generator.\n   *\n   * @param callback(err) called once the operation completes.\n   */\n  function _reseed(callback) {\n    if(ctx.pools[0].messageLength >= 32) {\n      _seed();\n      return callback();\n    }\n    // not enough seed data...\n    var needed = (32 - ctx.pools[0].messageLength) << 5;\n    ctx.seedFile(needed, function(err, bytes) {\n      if(err) {\n        return callback(err);\n      }\n      ctx.collect(bytes);\n      _seed();\n      callback();\n    });\n  }\n\n  /**\n   * Private function that synchronously reseeds a generator.\n   */\n  function _reseedSync() {\n    if(ctx.pools[0].messageLength >= 32) {\n      return _seed();\n    }\n    // not enough seed data...\n    var needed = (32 - ctx.pools[0].messageLength) << 5;\n    ctx.collect(ctx.seedFileSync(needed));\n    _seed();\n  }\n\n  /**\n   * Private function that seeds a generator once enough bytes are available.\n   */\n  function _seed() {\n    // update reseed count\n    ctx.reseeds = (ctx.reseeds === 0xffffffff) ? 0 : ctx.reseeds + 1;\n\n    // goal is to update `key` via:\n    // key = hash(key + s)\n    //   where 's' is all collected entropy from selected pools, then...\n\n    // create a plugin-based message digest\n    var md = ctx.plugin.md.create();\n\n    // consume current key bytes\n    md.update(ctx.keyBytes);\n\n    // digest the entropy of pools whose index k meet the\n    // condition 'n mod 2^k == 0' where n is the number of reseeds\n    var _2powK = 1;\n    for(var k = 0; k < 32; ++k) {\n      if(ctx.reseeds % _2powK === 0) {\n        md.update(ctx.pools[k].digest().getBytes());\n        ctx.pools[k].start();\n      }\n      _2powK = _2powK << 1;\n    }\n\n    // get digest for key bytes\n    ctx.keyBytes = md.digest().getBytes();\n\n    // paranoid deviation from Fortuna:\n    // update `seed` via `seed = hash(key)`\n    // instead of initializing to zero once and only\n    // ever incrementing it\n    md.start();\n    md.update(ctx.keyBytes);\n    var seedBytes = md.digest().getBytes();\n\n    // update state\n    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);\n    ctx.seed = ctx.plugin.formatSeed(seedBytes);\n    ctx.generated = 0;\n  }\n\n  /**\n   * The built-in default seedFile. This seedFile is used when entropy\n   * is needed immediately.\n   *\n   * @param needed the number of bytes that are needed.\n   *\n   * @return the random bytes.\n   */\n  function defaultSeedFile(needed) {\n    // use window.crypto.getRandomValues strong source of entropy if available\n    var getRandomValues = null;\n    var globalScope = forge.util.globalScope;\n    var _crypto = globalScope.crypto || globalScope.msCrypto;\n    if(_crypto && _crypto.getRandomValues) {\n      getRandomValues = function(arr) {\n        return _crypto.getRandomValues(arr);\n      };\n    }\n\n    var b = forge.util.createBuffer();\n    if(getRandomValues) {\n      while(b.length() < needed) {\n        // max byte length is 65536 before QuotaExceededError is thrown\n        // http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues\n        var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);\n        var entropy = new Uint32Array(Math.floor(count));\n        try {\n          getRandomValues(entropy);\n          for(var i = 0; i < entropy.length; ++i) {\n            b.putInt32(entropy[i]);\n          }\n        } catch(e) {\n          /* only ignore QuotaExceededError */\n          if(!(typeof QuotaExceededError !== 'undefined' &&\n            e instanceof QuotaExceededError)) {\n            throw e;\n          }\n        }\n      }\n    }\n\n    // be sad and add some weak random data\n    if(b.length() < needed) {\n      /* Draws from Park-Miller \"minimal standard\" 31 bit PRNG,\n      implemented with David G. Carta's optimization: with 32 bit math\n      and without division (Public Domain). */\n      var hi, lo, next;\n      var seed = Math.floor(Math.random() * 0x010000);\n      while(b.length() < needed) {\n        lo = 16807 * (seed & 0xFFFF);\n        hi = 16807 * (seed >> 16);\n        lo += (hi & 0x7FFF) << 16;\n        lo += hi >> 15;\n        lo = (lo & 0x7FFFFFFF) + (lo >> 31);\n        seed = lo & 0xFFFFFFFF;\n\n        // consume lower 3 bytes of seed\n        for(var i = 0; i < 3; ++i) {\n          // throw in more pseudo random\n          next = seed >>> (i << 3);\n          next ^= Math.floor(Math.random() * 0x0100);\n          b.putByte(String.fromCharCode(next & 0xFF));\n        }\n      }\n    }\n\n    return b.getBytes(needed);\n  }\n  // initialize seed file APIs\n  if(_crypto) {\n    // use nodejs async API\n    ctx.seedFile = function(needed, callback) {\n      _crypto.randomBytes(needed, function(err, bytes) {\n        if(err) {\n          return callback(err);\n        }\n        callback(null, bytes.toString());\n      });\n    };\n    // use nodejs sync API\n    ctx.seedFileSync = function(needed) {\n      return _crypto.randomBytes(needed).toString();\n    };\n  } else {\n    ctx.seedFile = function(needed, callback) {\n      try {\n        callback(null, defaultSeedFile(needed));\n      } catch(e) {\n        callback(e);\n      }\n    };\n    ctx.seedFileSync = defaultSeedFile;\n  }\n\n  /**\n   * Adds entropy to a prng ctx's accumulator.\n   *\n   * @param bytes the bytes of entropy as a string.\n   */\n  ctx.collect = function(bytes) {\n    // iterate over pools distributing entropy cyclically\n    var count = bytes.length;\n    for(var i = 0; i < count; ++i) {\n      ctx.pools[ctx.pool].update(bytes.substr(i, 1));\n      ctx.pool = (ctx.pool === 31) ? 0 : ctx.pool + 1;\n    }\n  };\n\n  /**\n   * Collects an integer of n bits.\n   *\n   * @param i the integer entropy.\n   * @param n the number of bits in the integer.\n   */\n  ctx.collectInt = function(i, n) {\n    var bytes = '';\n    for(var x = 0; x < n; x += 8) {\n      bytes += String.fromCharCode((i >> x) & 0xFF);\n    }\n    ctx.collect(bytes);\n  };\n\n  /**\n   * Registers a Web Worker to receive immediate entropy from the main thread.\n   * This method is required until Web Workers can access the native crypto\n   * API. This method should be called twice for each created worker, once in\n   * the main thread, and once in the worker itself.\n   *\n   * @param worker the worker to register.\n   */\n  ctx.registerWorker = function(worker) {\n    // worker receives random bytes\n    if(worker === self) {\n      ctx.seedFile = function(needed, callback) {\n        function listener(e) {\n          var data = e.data;\n          if(data.forge && data.forge.prng) {\n            self.removeEventListener('message', listener);\n            callback(data.forge.prng.err, data.forge.prng.bytes);\n          }\n        }\n        self.addEventListener('message', listener);\n        self.postMessage({forge: {prng: {needed: needed}}});\n      };\n    } else {\n      // main thread sends random bytes upon request\n      var listener = function(e) {\n        var data = e.data;\n        if(data.forge && data.forge.prng) {\n          ctx.seedFile(data.forge.prng.needed, function(err, bytes) {\n            worker.postMessage({forge: {prng: {err: err, bytes: bytes}}});\n          });\n        }\n      };\n      // TODO: do we need to remove the event listener when the worker dies?\n      worker.addEventListener('message', listener);\n    }\n  };\n\n  return ctx;\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","process","forge","_crypto","isNodejs","util","options","usePureJavaScript","versions","create","prng","prng.create","plugin","_reseed","callback","ctx","pools","messageLength","_seed","seedFile","err","bytes","collect","reseeds","md","update","keyBytes","_2powK","k","digest","getBytes","start","seedBytes","key","formatKey","seed","formatSeed","generated","defaultSeedFile","needed","getRandomValues","globalScope","crypto","msCrypto","arr","b","createBuffer","length","count","Math","max","min","entropy","Uint32Array","floor","i","putInt32","e","QuotaExceededError","random","lo","hi","next","putByte","String","fromCharCode","time","Array","pool","generate","ctx.generate","nextTick","cipher","putBytes","increment","setImmediate","generateSync","ctx.generateSync","seedFileSync","ctx.seedFile","randomBytes","toString","ctx.seedFileSync","ctx.collect","substr","collectInt","ctx.collectInt","n","x","registerWorker","ctx.registerWorker","worker","self","listener","data","removeEventListener","addEventListener","postMessage"]
}
