shadow$provide.module$node_modules$es6_promise$dist$es6_promise=function(global$jscomp$0,require,module,exports){var process=require("module$node_modules$process$browser");(function(global,factory){"object"===typeof exports&&"undefined"!==typeof module?module.exports=factory():"function"===typeof define&&define.amd?define(factory):global.ES6Promise=factory()})(this,function(){function isFunction(x){return"function"===typeof x}function useNextTick(){return function(){return process.nextTick(flush)}}
function useVertxTimer(){return"undefined"!==typeof vertxNext?function(){vertxNext(flush)}:useSetTimeout()}function useMutationObserver(){var iterations=0,observer=new BrowserMutationObserver(flush),node=document.createTextNode("");observer.observe(node,{characterData:!0});return function(){node.data=iterations=++iterations%2}}function useMessageChannel(){var channel=new MessageChannel;channel.port1.onmessage=flush;return function(){return channel.port2.postMessage(0)}}function useSetTimeout(){var globalSetTimeout=
setTimeout;return function(){return globalSetTimeout(flush,1)}}function flush(){for(var i=0;i<len;i+=2)(0,queue[i])(queue[i+1]),queue[i]=void 0,queue[i+1]=void 0;len=0}function attemptVertx(){try{var vertx=Function("return this")().require("vertx");vertxNext=vertx.runOnLoop||vertx.runOnContext;return useVertxTimer()}catch(e){return useSetTimeout()}}function then(onFulfillment,onRejection){var parent=this,child=new this.constructor(noop);void 0===child[PROMISE_ID]&&makePromise(child);var _state=parent._state;
if(_state){var callback=arguments[_state-1];asap(function(){return invokeCallback(_state,child,callback,parent._result)})}else subscribe(parent,child,onFulfillment,onRejection);return child}function resolve$1(object){if(object&&"object"===typeof object&&object.constructor===this)return object;var promise=new this(noop);resolve$jscomp$0(promise,object);return promise}function noop(){}function tryThen(then$$1,value,fulfillmentHandler,rejectionHandler){try{then$$1.call(value,fulfillmentHandler,rejectionHandler)}catch(e){return e}}
function handleForeignThenable(promise$jscomp$0,thenable,then$$1){asap(function(promise){var sealed=!1,error=tryThen(then$$1,thenable,function(value){sealed||(sealed=!0,thenable!==value?resolve$jscomp$0(promise,value):fulfill(promise,value))},function(reason){sealed||(sealed=!0,reject$jscomp$0(promise,reason))},"Settle: "+(promise._label||" unknown promise"));!sealed&&error&&(sealed=!0,reject$jscomp$0(promise,error))},promise$jscomp$0)}function handleOwnThenable(promise,thenable){thenable._state===
FULFILLED?fulfill(promise,thenable._result):thenable._state===REJECTED?reject$jscomp$0(promise,thenable._result):subscribe(thenable,void 0,function(value){return resolve$jscomp$0(promise,value)},function(reason){return reject$jscomp$0(promise,reason)})}function handleMaybeThenable(promise,maybeThenable,then$$1){maybeThenable.constructor===promise.constructor&&then$$1===then&&maybeThenable.constructor.resolve===resolve$1?handleOwnThenable(promise,maybeThenable):void 0===then$$1?fulfill(promise,maybeThenable):
isFunction(then$$1)?handleForeignThenable(promise,maybeThenable,then$$1):fulfill(promise,maybeThenable)}function resolve$jscomp$0(promise,value){if(promise===value)reject$jscomp$0(promise,new TypeError("You cannot resolve a promise with itself"));else{var type=typeof value;if(null===value||"object"!==type&&"function"!==type)fulfill(promise,value);else{type=void 0;try{type=value.then}catch(error){reject$jscomp$0(promise,error);return}handleMaybeThenable(promise,value,type)}}}function publishRejection(promise){promise._onerror&&
promise._onerror(promise._result);publish(promise)}function fulfill(promise,value){promise._state===PENDING&&(promise._result=value,promise._state=FULFILLED,0!==promise._subscribers.length&&asap(publish,promise))}function reject$jscomp$0(promise,reason){promise._state===PENDING&&(promise._state=REJECTED,promise._result=reason,asap(publishRejection,promise))}function subscribe(parent,child,onFulfillment,onRejection){var _subscribers=parent._subscribers,length=_subscribers.length;parent._onerror=null;
_subscribers[length]=child;_subscribers[length+FULFILLED]=onFulfillment;_subscribers[length+REJECTED]=onRejection;0===length&&parent._state&&asap(publish,parent)}function publish(promise){var subscribers=promise._subscribers,settled=promise._state;if(0!==subscribers.length){for(var child,callback,detail=promise._result,i=0;i<subscribers.length;i+=3)child=subscribers[i],callback=subscribers[i+settled],child?invokeCallback(settled,child,callback,detail):callback(detail);promise._subscribers.length=
0}}function invokeCallback(settled,promise,callback,detail){var hasCallback=isFunction(callback),value=void 0,error=void 0,succeeded=!0;if(hasCallback){try{value=callback(detail)}catch(e){succeeded=!1,error=e}if(promise===value){reject$jscomp$0(promise,new TypeError("A promises callback cannot return that same promise."));return}}else value=detail;promise._state===PENDING&&(hasCallback&&succeeded?resolve$jscomp$0(promise,value):!1===succeeded?reject$jscomp$0(promise,error):settled===FULFILLED?fulfill(promise,
value):settled===REJECTED&&reject$jscomp$0(promise,value))}function initializePromise(promise,resolver){try{resolver(function(value){resolve$jscomp$0(promise,value)},function(reason){reject$jscomp$0(promise,reason)})}catch(e){reject$jscomp$0(promise,e)}}function makePromise(promise){promise[PROMISE_ID]=id++;promise._state=void 0;promise._result=void 0;promise._subscribers=[]}var _isArray=void 0,isArray=_isArray=Array.isArray?Array.isArray:function(x){return"[object Array]"===Object.prototype.toString.call(x)},
len=0,vertxNext=void 0,customSchedulerFn=void 0,asap=function(callback,arg){queue[len]=callback;queue[len+1]=arg;len+=2;2===len&&(customSchedulerFn?customSchedulerFn(flush):scheduleFlush())},browserGlobal=(_isArray="undefined"!==typeof window?window:void 0)||{},BrowserMutationObserver=browserGlobal.MutationObserver||browserGlobal.WebKitMutationObserver;browserGlobal="undefined"===typeof self&&"undefined"!==typeof process&&"[object process]"==={}.toString.call(process);var isWorker="undefined"!==typeof Uint8ClampedArray&&
"undefined"!==typeof importScripts&&"undefined"!==typeof MessageChannel,queue=Array(1E3),scheduleFlush=void 0;scheduleFlush=browserGlobal?useNextTick():BrowserMutationObserver?useMutationObserver():isWorker?useMessageChannel():void 0===_isArray&&"function"===typeof require?attemptVertx():useSetTimeout();var PROMISE_ID=Math.random().toString(36).substring(2),PENDING=void 0,FULFILLED=1,REJECTED=2,id=0,Enumerator=function(){function Enumerator(Constructor,input){this._instanceConstructor=Constructor;
this.promise=new Constructor(noop);this.promise[PROMISE_ID]||makePromise(this.promise);isArray(input)?(this._remaining=this.length=input.length,this._result=Array(this.length),0===this.length?fulfill(this.promise,this._result):(this.length=this.length||0,this._enumerate(input),0===this._remaining&&fulfill(this.promise,this._result))):reject$jscomp$0(this.promise,Error("Array Methods must be provided an Array"))}Enumerator.prototype._enumerate=function(input){for(var i=0;this._state===PENDING&&i<input.length;i++)this._eachEntry(input[i],
i)};Enumerator.prototype._eachEntry=function(entry,i){var c=this._instanceConstructor,resolve$$1=c.resolve;if(resolve$$1===resolve$1){var error=resolve$$1=void 0,didError=!1;try{resolve$$1=entry.then}catch(e){didError=!0,error=e}resolve$$1===then&&entry._state!==PENDING?this._settledAt(entry._state,i,entry._result):"function"!==typeof resolve$$1?(this._remaining--,this._result[i]=entry):c===Promise$1?(c=new c(noop),didError?reject$jscomp$0(c,error):handleMaybeThenable(c,entry,resolve$$1),this._willSettleAt(c,
i)):this._willSettleAt(new c(function(resolve$$1){return resolve$$1(entry)}),i)}else this._willSettleAt(resolve$$1(entry),i)};Enumerator.prototype._settledAt=function(state,i,value){var promise=this.promise;promise._state===PENDING&&(this._remaining--,state===REJECTED?reject$jscomp$0(promise,value):this._result[i]=value);0===this._remaining&&fulfill(promise,this._result)};Enumerator.prototype._willSettleAt=function(promise,i){var enumerator=this;subscribe(promise,void 0,function(value){return enumerator._settledAt(FULFILLED,
i,value)},function(reason){return enumerator._settledAt(REJECTED,i,reason)})};return Enumerator}(),Promise$1=function(){function Promise(resolver){this[PROMISE_ID]=id++;this._result=this._state=void 0;this._subscribers=[];if(noop!==resolver){if("function"!==typeof resolver)throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");if(this instanceof Promise)initializePromise(this,resolver);else throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}}Promise.prototype.catch=function(onRejection){return this.then(null,onRejection)};Promise.prototype.finally=function(callback){var constructor=this.constructor;return isFunction(callback)?this.then(function(value){return constructor.resolve(callback()).then(function(){return value})},function(reason){return constructor.resolve(callback()).then(function(){throw reason;})}):this.then(callback,callback)};return Promise}();Promise$1.prototype.then=then;Promise$1.all=function(entries){return(new Enumerator(this,
entries)).promise};Promise$1.race=function(entries){var Constructor=this;return isArray(entries)?new Constructor(function(resolve,reject){for(var length=entries.length,i=0;i<length;i++)Constructor.resolve(entries[i]).then(resolve,reject)}):new Constructor(function(_,reject){return reject(new TypeError("You must pass an array to race."))})};Promise$1.resolve=resolve$1;Promise$1.reject=function(reason){var promise=new this(noop);reject$jscomp$0(promise,reason);return promise};Promise$1._setScheduler=
function(scheduleFn){customSchedulerFn=scheduleFn};Promise$1._setAsap=function(asapFn){asap=asapFn};Promise$1._asap=asap;Promise$1.polyfill=function(){var local=void 0;if("undefined"!==typeof global$jscomp$0)local=global$jscomp$0;else if("undefined"!==typeof self)local=self;else try{local=Function("return this")()}catch(e){throw Error("polyfill failed because global object is unavailable in this environment");}var P=local.Promise;if(P){var promiseToString=null;try{promiseToString=Object.prototype.toString.call(P.resolve())}catch(e$21){}if("[object Promise]"===
promiseToString&&!P.cast)return}local.Promise=Promise$1};return Promise$1.Promise=Promise$1})}
//# sourceMappingURL=module$node_modules$es6_promise$dist$es6_promise.js.map
