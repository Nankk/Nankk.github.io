["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$clojure.test.check","~:imports",null,"~:requires",["^ ","~$clojure.test.check.results","^;","~$rose","~$clojure.test.check.rose-tree","~$results","^;","~$clojure.test.check.impl","^?","^=","^=","~$clojure.test.check.generators","^@","~$gen","^@","~$clojure.test.check.random","^B","~$random","^B"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","~$get-current-time-millis","^?"],"~:defs",["^ ","~$shrink-loop",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/clojure/test/check.cljc","~:line",157,"~:column",8,"~:end-line",157,"~:end-column",19,"~:private",true,"~:arglists",["~#list",["~$quote",["^R",[["~$rose-tree","~$reporter-fn"]]]]],"~:doc","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step."],"^P",true,"^7","~$clojure.test.check/shrink-loop","^K","resources/public/js/compiled/test/out/clojure/test/check.cljc","^O",19,"~:method-params",["^R",[["^T","^U"]]],"~:protocol-impl",null,"~:arglists-meta",["^R",[null,null]],"^M",1,"~:variadic?",false,"^L",157,"~:ret-tag","~$cljs.core/IMap","^N",157,"~:max-fixed-arity",2,"~:fn-var",true,"^Q",["^R",["^S",["^R",[["^T","^U"]]]]],"^V","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step."],"~$failure",["^ ","^I",null,"^J",["^ ","^K","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/clojure/test/check.cljc","^L",212,"^M",8,"^N",212,"^O",15,"^P",true,"^Q",["^R",["^S",["^R",[["~$property","~$failing-rose-tree","~$trial-number","~$size","~$seed","~$start-time","^U"]]]]]],"^P",true,"^7","~$clojure.test.check/failure","^K","resources/public/js/compiled/test/out/clojure/test/check.cljc","^O",15,"^X",["^R",[["^15","^16","^17","^18","^19","^1:","^U"]]],"^Y",null,"^Z",["^R",[null,null]],"^M",1,"^[",false,"^L",212,"^10",["^6",["~$clj","~$any"]],"^N",212,"^12",7,"^13",true,"^Q",["^R",["^S",["^R",[["^15","^16","^17","^18","^19","^1:","^U"]]]]]],"~$make-rng",["^ ","^I",null,"^J",["^ ","^K","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/clojure/test/check.cljc","^L",19,"^M",8,"^N",19,"^O",16,"^P",true,"^Q",["^R",["^S",["^R",[["^19"]]]]]],"^P",true,"^7","~$clojure.test.check/make-rng","^K","resources/public/js/compiled/test/out/clojure/test/check.cljc","^O",16,"^X",["^R",[["^19"]]],"^Y",null,"^Z",["^R",[null,null]],"^M",1,"^[",false,"^L",19,"^10","~$cljs.core/IVector","^N",19,"^12",1,"^13",true,"^Q",["^R",["^S",["^R",[["^19"]]]]]],"~$complete",["^ ","^I",null,"^J",["^ ","^K","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/clojure/test/check.cljc","^L",26,"^M",8,"^N",26,"^O",16,"^P",true,"^Q",["^R",["^S",["^R",[["^15","~$num-trials","^19","^1:","^U"]]]]]],"^P",true,"^7","~$clojure.test.check/complete","^K","resources/public/js/compiled/test/out/clojure/test/check.cljc","^O",16,"^X",["^R",[["^15","^1B","^19","^1:","^U"]]],"^Y",null,"^Z",["^R",[null,null]],"^M",1,"^[",false,"^L",26,"^10","^11","^N",26,"^12",5,"^13",true,"^Q",["^R",["^S",["^R",[["^15","^1B","^19","^1:","^U"]]]]]],"~$legacy-result",["^ ","^I",null,"^J",["^ ","^K","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/clojure/test/check.cljc","^L",43,"^M",17,"^N",43,"^O",30,"^P",true,"^Q",["^R",["^S",["^R",[["~$result"]]]]],"^V","Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions."],"^P",true,"^7","~$clojure.test.check/legacy-result","^K","resources/public/js/compiled/test/out/clojure/test/check.cljc","^O",30,"^X",["^R",[["^1E"]]],"^Y",null,"^Z",["^R",[null,null]],"^M",1,"^[",false,"^L",43,"^10",["^6",[null,"^1=","~$cljs.core/ExceptionInfo","~$clj-nil"]],"^N",43,"^12",1,"^13",true,"^Q",["^R",["^S",["^R",[["^1E"]]]]],"^V","Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions."],"~$quick-check",["^ ","^I",null,"^J",["^ ","^K","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/clojure/test/check.cljc","^L",59,"^M",7,"^N",59,"^O",18,"^Q",["^R",["^S",["^R",[["~$num-tests","^15","~$&",["^ ","~:keys",["^19","~$max-size","^U"],"~:or",["^ ","^1L",200,"^U",["^R",["~$constantly",null]]]]]]]]],"^V","Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \"Uh oh...\"))))","~:top-fn",["^ ","^[",true,"~:fixed-arity",2,"^12",2,"^X",[["^R",["^1J","^15",["^ ","^1K",["^19","^1L","^U"],"^1M",["^ ","^1L",200,"^U",["^R",["^1N",null]]]]]]],"^Q",["^R",[["^1J","^15","~$&",["^ ","^1K",["^19","^1L","^U"],"^1M",["^ ","^1L",200,"^U",["^R",["^1N",null]]]]]]],"^Z",["^R",[null]]]],"^7","~$clojure.test.check/quick-check","^K","resources/public/js/compiled/test/out/clojure/test/check.cljc","^O",18,"^1O",["^ ","^[",true,"^1P",2,"^12",2,"^X",[["^R",["^1J","^15",["^ ","^1K",["^19","^1L","^U"],"^1M",["^ ","^1L",200,"^U",["^R",["^1N",null]]]]]]],"^Q",["^R",[["^1J","^15","~$&",["^ ","^1K",["^19","^1L","^U"],"^1M",["^ ","^1L",200,"^U",["^R",["^1N",null]]]]]]],"^Z",["^R",[null]]],"^X",[["^R",["^1J","^15",["^ ","^1K",["^19","^1L","^U"],"^1M",["^ ","^1L",200,"^U",["^R",["^1N",null]]]]]]],"^Y",null,"^1P",2,"^Z",["^R",[null]],"^M",1,"^[",true,"~:methods",[["^ ","^1P",2,"^[",true,"~:tag",["^6",["^1=","^11"]]]],"^L",59,"^10","^1=","^N",59,"^12",2,"^13",true,"^Q",["^R",[["^1J","^15","~$&",["^ ","^1K",["^19","^1L","^U"],"^1M",["^ ","^1L",200,"^U",["^R",["^1N",null]]]]]]],"^V","Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \"Uh oh...\"))))"],"~$smallest-shrink",["^ ","^I",null,"^J",["^ ","^K","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/clojure/test/check.cljc","^L",146,"^M",8,"^N",146,"^O",23,"^P",true,"^Q",["^R",["^S",["^R",[["~$total-nodes-visited","~$depth","~$smallest","^1:"]]]]]],"^P",true,"^7","~$clojure.test.check/smallest-shrink","^K","resources/public/js/compiled/test/out/clojure/test/check.cljc","^O",23,"^X",["^R",[["^1U","^1V","^1W","^1:"]]],"^Y",null,"^Z",["^R",[null,null]],"^M",1,"^[",false,"^L",146,"^10","^11","^N",146,"^12",4,"^13",true,"^Q",["^R",["^S",["^R",[["^1U","^1V","^1W","^1:"]]]]]]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","^A","^@","^@","^@"],"~:cljs.analyzer/constants",["^ ","~:seen",["^6",["~:args","~:clojure.test.check.properties/error","~:shrunk","~:failed-after-ms","~:total-nodes-visited","~:num-tests-total","~:failure","~:property","~:shrink-step","~:num-tests","~:type","~:max-size","~:seed","~:fail","~:result","~:result-data","~:smallest","~:trial","~:time-shrinking-ms","~:failing-size","~:reporter-fn","~:pass?","~:depth","~:complete","~:shrinking","~:time-elapsed-ms"]],"~:order",["^2;","^28","^2?","^2F","^2:","^2J","^2=","^2H","^22","^2<","^2E","^21","^26","^2@","^2B","^25","^2G","^2C","^2A","^2I","^29","^24","^2>","^2D","^27","^23"]],"^V",null]