["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$day8.re-frame.test","~:imports",null,"~:requires",["^ ","~$re-frame.interop","^;","~$test","~$cljs.test","~$rf","~$re-frame.core","^=","^=","~$re-frame.router","^@","~$rf.router","^@","~$rf.db","~$re-frame.db","~$rf.int","^;","^C","^C","^?","^?"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$t_day8$re_frame$test6296",["^ ","~:num-fields",3,"~:protocols",["^6",["~$cljs.core/IFn","~$cljs.core/IMeta","~$cljs.test/IAsyncTest","~$cljs.core/IWithMeta"]],"^7","~$day8.re-frame.test/t_day8$re_frame$test6296","~:file","resources/public/js/compiled/test/out/day8/re_frame/test.cljc","~:type",true,"~:anonymous",true,"~:column",14,"~:line",97,"~:record",false,"~:tag","~$function","~:skip-protocol-flag",["^6",["^K","^L","^N"]]],"~$*test-timeout*",["^ ","~:meta",["^ ","^P","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^T",49,"^S",16,"~:end-line",49,"~:end-column",30,"~:dynamic",true],"^7","~$day8.re-frame.test/*test-timeout*","^P","resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^10",30,"^S",1,"^11",true,"^T",49,"^[",49,"^V","~$number"],"~$run-test-async*",["^ ","~:protocol-inline",null,"^Z",["^ ","^P","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^T",61,"^S",7,"^[",61,"^10",22,"~:arglists",["~#list",["~$quote",["^17",[["~$f"]]]]]],"^7","~$day8.re-frame.test/run-test-async*","^P","resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^10",22,"~:method-params",["^17",[["~$f"]]],"~:protocol-impl",null,"~:arglists-meta",["^17",[null,null]],"^S",1,"~:variadic?",false,"^T",61,"~:ret-tag","^O","^[",61,"~:max-fixed-arity",1,"~:fn-var",true,"^16",["^17",["^18",["^17",[["~$f"]]]]]],"~$dequeue!",["^ ","^15",null,"^Z",["^ ","^P","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^T",16,"^S",8,"^[",16,"^10",16,"~:private",true,"^16",["^17",["^18",["^17",[["~$queue-atom"]]]]],"~:doc","Dequeue an item from a persistent queue which is stored as the value in\n  queue-atom. Returns the item, and updates the atom with the new queue\n  value. If the queue is empty, does not alter it and returns nil."],"^1B",true,"^7","~$day8.re-frame.test/dequeue!","^P","resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^10",16,"^1:",["^17",[["^1C"]]],"^1;",null,"^1<",["^17",[null,null]],"^S",1,"^1=",false,"^T",16,"^1>",["^6",["~$any","~$clj-nil"]],"^[",16,"^1?",1,"^1@",true,"^16",["^17",["^18",["^17",[["^1C"]]]]],"^1D","Dequeue an item from a persistent queue which is stored as the value in\n  queue-atom. Returns the item, and updates the atom with the new queue\n  value. If the queue is empty, does not alter it and returns nil."],"~$->t_day8$re_frame$test6296",["^ ","^15",null,"^Z",["^ ","^R",true,"^J",["^6",["^K","^L","^M","^N"]],"^X",["^6",["^K","^L","^N"]],"~:factory","~:positional","^16",["^17",["^18",["^17",[["~$f","~$test-context","~$meta6297"]]]]],"^1D","Positional factory function for day8.re-frame.test/t_day8$re_frame$test6296.","^P",null],"^J",["^6",["^K","^L","^M","^N"]],"^7","~$day8.re-frame.test/->t_day8$re_frame$test6296","^P","resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^1:",["^17",[["~$f","^1K","^1L"]]],"^1;",null,"^1<",["^17",[null,null]],"^R",true,"^S",14,"^1=",false,"^1I","^1J","^T",97,"^1>","^O","^1?",3,"^1@",true,"^16",["^17",["^18",["^17",[["~$f","^1K","^1L"]]]]],"^X",["^6",["^K","^L","^N"]],"^1D","Positional factory function for day8.re-frame.test/t_day8$re_frame$test6296."],"~$run-test-sync",["^ ","^15",null,"^Z",["^ ","^P","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^10",24,"~:top-fn",["^ ","^1=",true,"~:fixed-arity",0,"^1?",0,"^1:",["^17",[["^17",["~$body"]]]],"^16",["^17",[["~$&","^1Q"]]],"^1<",["^17",[null]]],"^S",11,"^T",288,"~:macro",true,"^[",288,"^16",["^17",["^18",["^17",[["~$&","^1Q"]]]]],"^1D","Execute `body` as a test, where each `dispatch` call is executed\n  synchronously (via `dispatch-sync`), and any subsequent dispatches which are\n  caused by that dispatch are also fully handled/executed prior to control flow\n  returning to your test.\n\n  Think of it kind of as though every `dispatch` in your app had been magically\n  turned into `dispatch-sync`, and re-frame had lifted the restriction that says\n  you can't call `dispatch-sync` from within an event handler.\n\n  Note that this is *not* achieved with blocking.  It relies on you not doing\n  anything asynchronous (such as an actual AJAX call or `js/setTimeout`)\n  directly in your event handlers.  In a real app running in the real browser,\n  of course that won't apply, so this might seem useless at first.  But if\n  you're a well-behaved re-framer, all of your asynchronous stuff (which is by\n  definition side-effecty) will happen in effectful event handlers installed\n  with `reg-fx`.  Which works very nicely: in your tests, install an alternative\n  version of those effectful event handlers which behaves synchronously.  For\n  maximum coolness, you might want to consider running your tests on the JVM and\n  installing a `reg-fx` handler which actually invokes your JVM Clojure\n  server-side Ring handler where your in-browser code would make an AJAX call."],"^7","~$day8.re-frame.test/run-test-sync","^P","resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^10",24,"^1O",["^ ","^1=",true,"^1P",0,"^1?",0,"^1:",["^17",[["^17",["^1Q"]]]],"^16",["^17",[["~$&","^1Q"]]],"^1<",["^17",[null]]],"^1:",["^17",[["^17",["^1Q"]]]],"^1;",null,"^1P",0,"^1<",["^17",[null]],"^S",1,"^1=",true,"~:methods",[["^ ","^1P",0,"^1=",true,"^V",["^6",["~$seq","~$cljs.core/IList"]]]],"^T",288,"^1R",true,"^1>","^1F","^[",288,"^1?",0,"^1@",false,"^16",["^17",[["~$&","^1Q"]]],"^1D","Execute `body` as a test, where each `dispatch` call is executed\n  synchronously (via `dispatch-sync`), and any subsequent dispatches which are\n  caused by that dispatch are also fully handled/executed prior to control flow\n  returning to your test.\n\n  Think of it kind of as though every `dispatch` in your app had been magically\n  turned into `dispatch-sync`, and re-frame had lifted the restriction that says\n  you can't call `dispatch-sync` from within an event handler.\n\n  Note that this is *not* achieved with blocking.  It relies on you not doing\n  anything asynchronous (such as an actual AJAX call or `js/setTimeout`)\n  directly in your event handlers.  In a real app running in the real browser,\n  of course that won't apply, so this might seem useless at first.  But if\n  you're a well-behaved re-framer, all of your asynchronous stuff (which is by\n  definition side-effecty) will happen in effectful event handlers installed\n  with `reg-fx`.  Which works very nicely: in your tests, install an alternative\n  version of those effectful event handlers which behaves synchronously.  For\n  maximum coolness, you might want to consider running your tests on the JVM and\n  installing a `reg-fx` handler which actually invokes your JVM Clojure\n  server-side Ring handler where your in-browser code would make an AJAX call."],"~$as-callback-pred",["^ ","^15",null,"^Z",["^ ","^P","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^T",123,"^S",8,"^[",123,"^10",24,"^1B",true,"^16",["^17",["^18",["^17",[["~$callback-pred"]]]]],"^1D","Interprets the acceptable input values for `wait-for`'s `ok-ids` and\n  `failure-ids` params to produce a predicate function on an event.  See\n  `wait-for` for details."],"^1B",true,"^7","~$day8.re-frame.test/as-callback-pred","^P","resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^10",24,"^1:",["^17",[["^1X"]]],"^1;",null,"^1<",["^17",[null,null]],"^S",1,"^1=",false,"^T",123,"^1>",["^6",[null,"^W","^1G"]],"^[",123,"^1?",1,"^1@",true,"^16",["^17",["^18",["^17",[["^1X"]]]]],"^1D","Interprets the acceptable input values for `wait-for`'s `ok-ids` and\n  `failure-ids` params to produce a predicate function on an event.  See\n  `wait-for` for details."],"~$wait-for*",["^ ","^15",null,"^Z",["^ ","^P","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^T",142,"^S",7,"^[",142,"^10",16,"^16",["^17",["^18",["^17",[["~$ok-ids","~$failure-ids","~$callback"]]]]],"^1D","This function is an implementation detail: in your async tests (within a\n  `run-test-async`), you should use the `wait-for` macro instead.  (For\n  synchronous tests within `run-test-sync`, you don't need this capability at\n  all.)\n\n  Installs `callback` as a re-frame post-event callback handler, called as soon\n  as any event matching `ok-ids` is handled.  Aborts the test as a failure if\n  any event matching `failure-ids` is handled.\n\n  Since this is intended for use in asynchronous tests: it will return\n  immediately after installing the callback -- it doesn't *actually* wait.\n\n  Note that `wait-for*` tracks whether, during your callback, you call\n  `wait-for*` again.  If you *don't*, then, given the way asynchronous tests\n  work, your test must necessarily be finished.  So `wait-for*` will\n  call `(done)` for you."],"^7","~$day8.re-frame.test/wait-for*","^P","resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^10",16,"^1:",["^17",[["^1[","^20","^21"]]],"^1;",null,"^1<",["^17",[null,null]],"^S",1,"^1=",false,"^T",142,"^1>",["^6",[null,"^1F"]],"^[",142,"^1?",3,"^1@",true,"^16",["^17",["^18",["^17",[["^1[","^20","^21"]]]]],"^1D","This function is an implementation detail: in your async tests (within a\n  `run-test-async`), you should use the `wait-for` macro instead.  (For\n  synchronous tests within `run-test-sync`, you don't need this capability at\n  all.)\n\n  Installs `callback` as a re-frame post-event callback handler, called as soon\n  as any event matching `ok-ids` is handled.  Aborts the test as a failure if\n  any event matching `failure-ids` is handled.\n\n  Since this is intended for use in asynchronous tests: it will return\n  immediately after installing the callback -- it doesn't *actually* wait.\n\n  Note that `wait-for*` tracks whether, during your callback, you call\n  `wait-for*` again.  If you *don't*, then, given the way asynchronous tests\n  work, your test must necessarily be finished.  So `wait-for*` will\n  call `(done)` for you."],"~$run-test-async",["^ ","^15",null,"^Z",["^ ","^P","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^10",25,"^1O",["^ ","^1=",true,"^1P",0,"^1?",0,"^1:",["^17",[["^17",["^1Q"]]]],"^16",["^17",[["~$&","^1Q"]]],"^1<",["^17",[null]]],"^S",11,"^T",103,"^1R",true,"^[",103,"^16",["^17",["^18",["^17",[["~$&","^1Q"]]]]],"^1D","Run `body` as an async re-frame test. The async nature means you'll need to\n  use `wait-for` any time you want to make any assertions that should be true\n  *after* an event has been handled.  It's assumed that there will be at least\n  one `wait-for` in the body of your test (otherwise you don't need this macro\n  at all).\n\n  Note: unlike regular ClojureScript `cljs.test/async` tests, `wait-for` takes\n  care of calling `(done)` for you: you don't need to do anything specific to\n  handle the fact that your test is asynchronous, other than make sure that all\n  your assertions happen with `wait-for` blocks.\n\n  This macro will automatically clean up any changes to re-frame state made\n  within the test body, as per `with-temp-re-frame-state` (except that the way\n  it's done here *does* work for async tests, whereas that macro used by itself\n  doesn't)."],"^7","~$day8.re-frame.test/run-test-async","^P","resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^10",25,"^1O",["^ ","^1=",true,"^1P",0,"^1?",0,"^1:",["^17",[["^17",["^1Q"]]]],"^16",["^17",[["~$&","^1Q"]]],"^1<",["^17",[null]]],"^1:",["^17",[["^17",["^1Q"]]]],"^1;",null,"^1P",0,"^1<",["^17",[null]],"^S",1,"^1=",true,"^1T",[["^ ","^1P",0,"^1=",true,"^V",["^6",["^1U","^1V"]]]],"^T",103,"^1R",true,"^1>","^1F","^[",103,"^1?",0,"^1@",false,"^16",["^17",[["~$&","^1Q"]]],"^1D","Run `body` as an async re-frame test. The async nature means you'll need to\n  use `wait-for` any time you want to make any assertions that should be true\n  *after* an event has been handled.  It's assumed that there will be at least\n  one `wait-for` in the body of your test (otherwise you don't need this macro\n  at all).\n\n  Note: unlike regular ClojureScript `cljs.test/async` tests, `wait-for` takes\n  care of calling `(done)` for you: you don't need to do anything specific to\n  handle the fact that your test is asynchronous, other than make sure that all\n  your assertions happen with `wait-for` blocks.\n\n  This macro will automatically clean up any changes to re-frame state made\n  within the test body, as per `with-temp-re-frame-state` (except that the way\n  it's done here *does* work for async tests, whereas that macro used by itself\n  doesn't)."],"~$run-test-sync*",["^ ","^15",null,"^Z",["^ ","^P","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^T",270,"^S",7,"^[",270,"^10",21,"^16",["^17",["^18",["^17",[["~$f"]]]]]],"^7","~$day8.re-frame.test/run-test-sync*","^P","resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^10",21,"^1:",["^17",[["~$f"]]],"^1;",null,"^1<",["^17",[null,null]],"^S",1,"^1=",false,"^T",270,"^[",270,"^1?",1,"^1@",true,"^16",["^17",["^18",["^17",[["~$f"]]]]]],"~$*test-context*",["^ ","^Z",["^ ","^P","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^T",51,"^S",38,"^[",51,"^10",52,"^11",true,"^1B",true],"^1B",true,"^7","~$day8.re-frame.test/*test-context*","^P","resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^10",52,"^S",1,"^11",true,"^T",51,"^[",51,"^V","^1G","^1D","~`*test-context*` is used to communicate internal details of the test between\n  `run-test-async*` and `wait-for*`. It is dynamically bound so that it doesn't\n  need to appear as a lexical argument to a `wait-for` block, since we don't\n  want it to be visible when you're writing tests.  But care must be taken to\n  pass it around lexically across callbacks, since ClojureScript doesn't have\n  `bound-fn`."],"~$*handling*",["^ ","^Z",["^ ","^P","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^T",268,"^S",38,"^[",268,"^10",48,"^11",true,"^1B",true],"^1B",true,"^7","~$day8.re-frame.test/*handling*","^P","resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^10",48,"^S",1,"^11",true,"^T",268,"^[",268,"^V","~$boolean"],"~$wait-for",["^ ","^15",null,"^Z",["^ ","^P","/home/nankk/Dropbox/cljs/rock-paper-scissors/resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^10",19,"^1O",["^ ","^1=",true,"^1P",1,"^1?",1,"^1:",["^17",[["^17",[["~$ids","^20","~$event-sym","~:as","~$argv"],"^1Q"]]]],"^16",["^17",[[["^2=","^20","^2>","^2?","^2@"],"~$&","^1Q"]]],"^1<",["^17",[null]]],"^S",11,"^T",206,"^1R",true,"^[",206,"^16",["^17",["^18",["^17",[[["^2=","^20","^2>","^2?","^2@"],"~$&","^1Q"]]]]],"^1D","Execute `body` once an event identified by the predicate(s) `ids` has been handled.\n\n  `ids` and `failure-ids` are means to identify an event. Normally, each would\n  be a simple keyword or a set of keywords.  If an event with event-id of (or\n  in) `ids` is handled, the test will continue by executing the body. If an\n  event with an event-id of (or in) `failure-ids` is handled, the test will\n  abort and fail.\n\n  IMPORTANT NOTE: due to the way async tests in re-frame work, code you want\n  executed after the event you're waiting for has to happen in the `body` of the\n  `wait-for` (in an implicit callback), not just lexically after the the\n  `wait-for` call. In practice, this means `wait-for` must always be in a tail\n  position.\n\n  Eg:\n      (run-test-async\n        (dispatch [:get-user 2])\n        (wait-for [#{:got-user} #{:no-such-user :system-unavailable} event]\n          (is (= (:username @(subscribe [:user])) \"johnny\")))\n        ;; Don't put code here, it will run *before* the event you're waiting\n        ;; for.\n        )\n\n  Acceptable inputs for `ids` and `failure-ids` are:\n    - `:some-event-id` => matches an event with that ID\n\n    - `#{:some-event-id :other-event-id}` => matches an event with any of the\n                                             given IDs\n\n    - `[:some-event-id :other-event-id]` => ditto (checks in order)\n\n    - `(fn [event] ,,,) => uses the function as a predicate\n\n    - `[(fn [event] ,,,) (fn [event] ,,,)]` => tries each predicate in turn,\n                                               matching an event which matches\n                                               at least one predicate\n\n    - `#{:some-event-id (fn [event] ,,,)}` => tries each\n\n  Note that because we're liberal about whether you supply `failure-ids` and/or\n  `event-sym`, if you do choose to supply only one, and you want that one to be\n  `event-sym`, you can't supply it as a destructuring form (because we can't\n  disambiguate that from a vector of `failure-ids`).  You can just supply `nil`\n  as `failure-ids` in this case, and then you'll be able to destructure."],"^7","~$day8.re-frame.test/wait-for","^P","resources/public/js/compiled/test/out/day8/re_frame/test.cljc","^10",19,"^1O",["^ ","^1=",true,"^1P",1,"^1?",1,"^1:",["^17",[["^17",[["^2=","^20","^2>","^2?","^2@"],"^1Q"]]]],"^16",["^17",[[["^2=","^20","^2>","^2?","^2@"],"~$&","^1Q"]]],"^1<",["^17",[null]]],"^1:",["^17",[["^17",[["^2=","^20","^2>","^2?","^2@"],"^1Q"]]]],"^1;",null,"^1P",1,"^1<",["^17",[null]],"^S",1,"^1=",true,"^1T",[["^ ","^1P",1,"^1=",true,"^V",["^6",["^1U","^1V"]]]],"^T",206,"^1R",true,"^1>","^1F","^[",206,"^1?",1,"^1@",false,"^16",["^17",[[["^2=","^20","^2>","^2?","^2@"],"~$&","^1Q"]]],"^1D","Execute `body` once an event identified by the predicate(s) `ids` has been handled.\n\n  `ids` and `failure-ids` are means to identify an event. Normally, each would\n  be a simple keyword or a set of keywords.  If an event with event-id of (or\n  in) `ids` is handled, the test will continue by executing the body. If an\n  event with an event-id of (or in) `failure-ids` is handled, the test will\n  abort and fail.\n\n  IMPORTANT NOTE: due to the way async tests in re-frame work, code you want\n  executed after the event you're waiting for has to happen in the `body` of the\n  `wait-for` (in an implicit callback), not just lexically after the the\n  `wait-for` call. In practice, this means `wait-for` must always be in a tail\n  position.\n\n  Eg:\n      (run-test-async\n        (dispatch [:get-user 2])\n        (wait-for [#{:got-user} #{:no-such-user :system-unavailable} event]\n          (is (= (:username @(subscribe [:user])) \"johnny\")))\n        ;; Don't put code here, it will run *before* the event you're waiting\n        ;; for.\n        )\n\n  Acceptable inputs for `ids` and `failure-ids` are:\n    - `:some-event-id` => matches an event with that ID\n\n    - `#{:some-event-id :other-event-id}` => matches an event with any of the\n                                             given IDs\n\n    - `[:some-event-id :other-event-id]` => ditto (checks in order)\n\n    - `(fn [event] ,,,) => uses the function as a predicate\n\n    - `[(fn [event] ,,,) (fn [event] ,,,)]` => tries each predicate in turn,\n                                               matching an event which matches\n                                               at least one predicate\n\n    - `#{:some-event-id (fn [event] ,,,)}` => tries each\n\n  Note that because we're liberal about whether you supply `failure-ids` and/or\n  `event-sym`, if you do choose to supply only one, and you want that one to be\n  `event-sym`, you can't supply it as a destructuring form (because we can't\n  disambiguate that from a vector of `failure-ids`).  You can just supply `nil`\n  as `failure-ids` in this case, and then you'll be able to destructure."]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","^8","^8","^<","^=","^=","^="],"~:cljs.analyzer/constants",["^ ","~:seen",["^6",["~:max-wait-for-depth","^1K","~:done","~:else","~:now-waiting-for","^22","^19","^Q","~:wait-for-depth","~:fail","~$fail-pred","~:callback-pred","~$not","^26","~:expected","~$cljs.core/fn","~:error","~$event","~:pass","~:actual","^1L","~:message","~$f"]],"~:order",["^2J","^2F","^2I","^2G","~$f","^1K","^1L","^19","^2P","^2H","^2M","^Q","^2O","^2T","^2U","^2Q","^2N","^2L","^2R","^2S","^2K","^22","^26"]],"^1D",null]